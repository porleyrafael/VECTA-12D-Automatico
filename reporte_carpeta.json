{
  "fecha_analisis": "2025-12-25T20:38:33.960278",
  "ruta_carpeta": "C:\\Users\\Rafael\\Desktop\\VECTA 12D Automatico",
  "estructura": {
    "__pycache__": {
      "tipo": "carpeta",
      "ruta": "__pycache__",
      "contenido": {
        "vecta_launcher.cpython-313.pyc": {
          "tipo": "archivo",
          "extension": ".pyc",
          "tamano_bytes": 16190,
          "tamano_humano": "15.81 KB",
          "ruta": "__pycache__\\vecta_launcher.cpython-313.pyc",
          "contenido_preview": null
        }
      }
    },
    "core": {
      "tipo": "carpeta",
      "ruta": "core",
      "contenido": {
        "__pycache__": {
          "tipo": "carpeta",
          "ruta": "core\\__pycache__",
          "contenido": {
            "__init__.cpython-313.pyc": {
              "tipo": "archivo",
              "extension": ".pyc",
              "tamano_bytes": 158,
              "tamano_humano": "0.15 KB",
              "ruta": "core\\__pycache__\\__init__.cpython-313.pyc",
              "contenido_preview": null
            },
            "meta_vecta.cpython-313.pyc": {
              "tipo": "archivo",
              "extension": ".pyc",
              "tamano_bytes": 34016,
              "tamano_humano": "33.22 KB",
              "ruta": "core\\__pycache__\\meta_vecta.cpython-313.pyc",
              "contenido_preview": null
            },
            "vecta_12d_core.cpython-313.pyc": {
              "tipo": "archivo",
              "extension": ".pyc",
              "tamano_bytes": 2752,
              "tamano_humano": "2.69 KB",
              "ruta": "core\\__pycache__\\vecta_12d_core.cpython-313.pyc",
              "contenido_preview": null
            }
          }
        },
        "__init__.py": {
          "tipo": "archivo",
          "extension": ".py",
          "tamano_bytes": 16,
          "tamano_humano": "0.02 KB",
          "ruta": "core\\__init__.py",
          "contenido_preview": "# Paquete core\n"
        },
        "config_manager.py": {
          "tipo": "archivo",
          "extension": ".py",
          "tamano_bytes": 139,
          "tamano_humano": "0.14 KB",
          "ruta": "core\\config_manager.py",
          "contenido_preview": "\"\"\"\nGESTOR DE CONFIGURACION\n\"\"\"\nimport json\n\nclass ConfigManager:\n    def __init__(self):\n        self.config = {\"version\": \"2.0.0\"}"
        },
        "meta_vecta.py": {
          "tipo": "archivo",
          "extension": ".py",
          "tamano_bytes": 32383,
          "tamano_humano": "31.62 KB",
          "ruta": "core\\meta_vecta.py",
          "contenido_preview": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nMETA-VECTA CORE - Especificaci√≥n Ejecutable 1.0\n===============================================\nN√∫cleo filos√≥fico y l√≥gico del sistema VECTA\nBasado en la especificaci√≥n unificada de Rafael Porley\n\"\"\"\n\nimport json\nimport time\nimport math\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Any, Tuple, Optional\nfrom enum import Enum\nimport hashlib\n\n# ==================== SECCI√ìN 1 - META-VECTA CORE ====================\n\nclass VECTAPrinciple(Enum):\n    \"\"\"Principios inmutables de META-VECTA\"\"\"\n    ALWAYS_DECIDE = \"P1: ALWAYS_DECIDE\"\n    FINITE_TIME_COLLAPSE = \"P2: FINITE_TIME_COLLAPSE\"\n    NO_COMPLEXITY_WITHOUT_GAIN = \"P3: NO_COMPLEXITY_WITHOUT_GAIN\"\n    FULL_AUDITABILITY = \"P4: FULL_AUDITABILITY\"\n    SEPARATION_OF_LAYERS = \"P5: SEPARATION_OF_LAYERS\"\n\nclass MetaVECTA:\n    \"\"\"N√∫cleo inmutable de principios META-VECTA\"\"\"\n    \n    def __init__(self):\n        self.immutable = True\n        self.creation_time = time.time()\n        self.creator = \"Rafael Porley\"\n        self.version = \"1.0\"\n        self.purpose = \"Portable definition to teach any IA or PC runtime how VECTA works\"\n        \n        # Principios fundamentales\n        self.principles = {\n            VECTAPrinciple.ALWAYS_DECIDE: \"No non-execution allowed\",\n            VECTAPrinciple.FINITE_TIME_COLLAPSE: \"Decisions must resolve in finite time\",\n            VECTAPrinciple.NO_COMPLEXITY_WITHOUT_GAIN: \"Complexity must be justified\",\n            VECTAPrinciple.FULL_AUDITABILITY: \"Every change is logged\",\n            VECTAPrinciple.SEPARATION_OF_LAYERS: \"Language ‚â† Intention ‚â† Execution\"\n        }\n        \n        # Operador Salom√≥n\n        self.operator_salomon = {\n            \"description\": \"Forced decision under undecidable superposition\",\n            \"rule\": \"IF (SUPERPOSITION_TIME > T_MAX) THEN SELECT ACTION THAT MINIMIZES IRREVERSIBLE_DAMAGE\",\n            \"t_max\": 5.0  # 5 segundos m√°ximo para decisiones\n        }\n        \n        # M√©trica de validez global\n        self.validity_metric = {\n            \"requirements\": {\n                \"delta_information_density\": \"> 0\",\n                \"delta_decision_time\": \"<= 0\",\n                \"delta_accumulated_error\": \"<= epsilon\"\n            },\n            \"epsilon\": 0.001,\n            \"failure_action\": \"ROLLBACK_IMMEDIATE\"\n        }\n        \n        # Log de auditor√≠a\n        self.audit_log = []\n        self._log_event(\"META_VECTA_CORE_INITIALIZED\", {\n            \"timestamp\": self.creation_time,\n            \"version\": self.version,\n            \"creator\": self.creator\n        })\n    \n    def _log_event(self, event_type: str, data: Dict):\n        \"\"\"Registro de auditor√≠a inmutable\"\"\"\n        event = {\n            \"type\": event_type,\n            \"data\": data,\n            \"timestamp\": time.time(),\n            \"hash\": hashlib.sha256(str(data).encode()).hexdigest()[:16]\n        }\n        self.audit_log.append(event)\n        return event\n    \n    def apply_operator_salomon(self, superposition_time: float, options: List[Dict]) -> Dict:\n        \"\"\"Aplica el operador Salom√≥n para decisiones forzadas\"\"\"\n        if superposition_time > self.operator_salomon[\"t_max\"]:\n            self._log_event(\"OPERATOR_SALOMON_APPLIED\", {\n                \"superposition_time\": superposition_time,\n                \"t_max\": self.operator_salomon[\"t_max\"],\n                \"options_count\": len(options)\n            })\n            \n            # Seleccionar la opci√≥n que minimiza da√±o irreversible\n            # (simulaci√≥n - en pr√°ctica se usar√≠a una m√©trica real)\n            if options:\n                return min(options, key=lambda x: x.get('irreversible_damage', 0))\n        \n        return {\"decision\": \"CONTINUE_SUPERPOSITION\", \"reason\": \"WITHIN_TIME_LIMIT\"}\n    \n    def validate_decision(self, decision_data: Dict) -> Tuple[bool, str]:\n        \"\"\"Valida una decisi√≥n contra la m√©trica global\"\"\"\n        try:\n            # Verificar densidad de informaci√≥n\n            if decision_data.get('information_density', 0) <= 0:\n                return False, \"DELTA_INFORMATION_DENSITY <= 0\"\n            \n            # Verificar tiempo de decisi√≥n\n            if decision_data.get('decision_time', 0) > 0:\n                return False, \"DELTA_DECISION_TIME > 0\"\n            \n            # Verificar error acumulado\n            epsilon = self.validity_metric[\"epsilon\"]\n            if decision_data.get('accumulated_error', epsilon + 1) > epsilon:\n                return False, f\"DELTA_ACCUMULATED_ERROR > {epsilon}\"\n            \n            self._log_event(\"DECISION_VALIDATED\", decision_data)\n            return True, \"VALID\"\n            \n        except Exception as e:\n            return False, f\"VALIDATION_ERROR: {str(e)}\"\n\n# ==================== SECCI√ìN 2 - VECTA LANGUAGE CORE ====================\n\n@dataclass\nclass VECTASymbol:\n    \"\"\"Estructura de s√≠mbolo VECTA\"\"\"\n    form: str\n    orientation: Tuple[float, float, float]  # (x, y, z)\n    weight: float      # œâ - Intensidad/Relevancia\n    phase: floa"
        },
        "vecta_12d_core.py": {
          "tipo": "archivo",
          "extension": ".py",
          "tamano_bytes": 1759,
          "tamano_humano": "1.72 KB",
          "ruta": "core\\vecta_12d_core.py",
          "contenido_preview": "\"\"\"\nNUCLEO VECTA 12D\n\"\"\"\nimport sys\nimport os\nsys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))\n\ntry:\n    from dimensiones.vector_12d import SistemaVectorial12D\n    SISTEMA_DISPONIBLE = True\nexcept:\n    SISTEMA_DISPONIBLE = False\n\nclass VECTA_12D_Core:\n    def __init__(self):\n        self.nombre = \"VECTA 12D\"\n        self.version = \"2.0.0\"\n        \n        if SISTEMA_DISPONIBLE:\n            self.sistema = SistemaVectorial12D()\n            self.estado = \"sistema_cargado\"\n        else:\n            self.sistema = None\n            self.estado = \"sistema_no_disponible\"\n    \n    def procesar(self, texto):\n        if self.sistema:\n            try:\n                vector = self.sistema.procesar_evento({\"texto\": texto})\n                return {\n                    \"exito\": True,\n                    \"magnitud\": vector.magnitud(),\n                    \"dimensiones\": vector.dimensiones\n                }\n            except Exception as e:\n                return {\"exito\": False, \"error\": str(e)}\n        else:\n            return {\"exito\": False, \"error\": \"Sistema no disponible\"}\n    \n    def start_text_interface(self):\n        print(\"\\n=== VECTA 12D ===\")\n        print(\"Escribe 'salir' para terminar\\n\")\n        \n        while True:\n            try:\n                entrada = input(\"VECTA> \")\n                if entrada.lower() == 'salir':\n                    break\n                \n                resultado = self.procesar(entrada)\n                if resultado.get(\"exito\"):\n                    print(f\"Vector: {resultado['magnitud']:.4f}\")\n                else:\n                    print(f\"Error: {resultado.get('error')}\")\n            except KeyboardInterrupt:\n                break\n"
        }
      }
    },
    "dimensiones": {
      "tipo": "carpeta",
      "ruta": "dimensiones",
      "contenido": {
        "__pycache__": {
          "tipo": "carpeta",
          "ruta": "dimensiones\\__pycache__",
          "contenido": {
            "dimension_1.cpython-313.pyc": {
              "tipo": "archivo",
              "extension": ".pyc",
              "tamano_bytes": 973,
              "tamano_humano": "0.95 KB",
              "ruta": "dimensiones\\__pycache__\\dimension_1.cpython-313.pyc",
              "contenido_preview": null
            },
            "dimension_10.cpython-313.pyc": {
              "tipo": "archivo",
              "extension": ".pyc",
              "tamano_bytes": 925,
              "tamano_humano": "0.90 KB",
              "ruta": "dimensiones\\__pycache__\\dimension_10.cpython-313.pyc",
              "contenido_preview": null
            },
            "dimension_11.cpython-313.pyc": {
              "tipo": "archivo",
              "extension": ".pyc",
              "tamano_bytes": 900,
              "tamano_humano": "0.88 KB",
              "ruta": "dimensiones\\__pycache__\\dimension_11.cpython-313.pyc",
              "contenido_preview": null
            },
            "dimension_12.cpython-313.pyc": {
              "tipo": "archivo",
              "extension": ".pyc",
              "tamano_bytes": 925,
              "tamano_humano": "0.90 KB",
              "ruta": "dimensiones\\__pycache__\\dimension_12.cpython-313.pyc",
              "contenido_preview": null
            },
            "dimension_2.cpython-313.pyc": {
              "tipo": "archivo",
              "extension": ".pyc",
              "tamano_bytes": 893,
              "tamano_humano": "0.87 KB",
              "ruta": "dimensiones\\__pycache__\\dimension_2.cpython-313.pyc",
              "contenido_preview": null
            },
            "dimension_3.cpython-313.pyc": {
              "tipo": "archivo",
              "extension": ".pyc",
              "tamano_bytes": 903,
              "tamano_humano": "0.88 KB",
              "ruta": "dimensiones\\__pycache__\\dimension_3.cpython-313.pyc",
              "contenido_preview": null
            },
            "dimension_4.cpython-313.pyc": {
              "tipo": "archivo",
              "extension": ".pyc",
              "tamano_bytes": 918,
              "tamano_humano": "0.90 KB",
              "ruta": "dimensiones\\__pycache__\\dimension_4.cpython-313.pyc",
              "contenido_preview": null
            },
            "dimension_5.cpython-313.pyc": {
              "tipo": "archivo",
              "extension": ".pyc",
              "tamano_bytes": 913,
              "tamano_humano": "0.89 KB",
              "ruta": "dimensiones\\__pycache__\\dimension_5.cpython-313.pyc",
              "contenido_preview": null
            },
            "dimension_6.cpython-313.pyc": {
              "tipo": "archivo",
              "extension": ".pyc",
              "tamano_bytes": 918,
              "tamano_humano": "0.90 KB",
              "ruta": "dimensiones\\__pycache__\\dimension_6.cpython-313.pyc",
              "contenido_preview": null
            },
            "dimension_7.cpython-313.pyc": {
              "tipo": "archivo",
              "extension": ".pyc",
              "tamano_bytes": 928,
              "tamano_humano": "0.91 KB",
              "ruta": "dimensiones\\__pycache__\\dimension_7.cpython-313.pyc",
              "contenido_preview": null
            },
            "dimension_8.cpython-313.pyc": {
              "tipo": "archivo",
              "extension": ".pyc",
              "tamano_bytes": 928,
              "tamano_humano": "0.91 KB",
              "ruta": "dimensiones\\__pycache__\\dimension_8.cpython-313.pyc",
              "contenido_preview": null
            },
            "dimension_9.cpython-313.pyc": {
              "tipo": "archivo",
              "extension": ".pyc",
              "tamano_bytes": 898,
              "tamano_humano": "0.88 KB",
              "ruta": "dimensiones\\__pycache__\\dimension_9.cpython-313.pyc",
              "contenido_preview": null
            },
            "vector_12d.cpython-313.pyc": {
              "tipo": "archivo",
              "extension": ".pyc",
              "tamano_bytes": 5587,
              "tamano_humano": "5.46 KB",
              "ruta": "dimensiones\\__pycache__\\vector_12d.cpython-313.pyc",
              "contenido_preview": null
            }
          }
        },
        "dimension_1.py": {
          "tipo": "archivo",
          "extension": ".py",
          "tamano_bytes": 316,
          "tamano_humano": "0.31 KB",
          "ruta": "dimensiones\\dimension_1.py",
          "contenido_preview": "\"\"\"\nDIMENSION 1: Tiempo-Entropia\n\"\"\"\n\n\nclass DimensionTiempoEntropia:\n    def __init__(self):\n        self.nombre = \"Tiempo-Entropia\"\n        self.magnitud = 0.0\n    \n    def procesar(self, datos):\n        import time\n        return {\"dimension\": self.nombre, \"magnitud\": 0.5, \"timestamp\": time.time()}\n"
        },
        "dimension_10.py": {
          "tipo": "archivo",
          "extension": ".py",
          "tamano_bytes": 288,
          "tamano_humano": "0.28 KB",
          "ruta": "dimensiones\\dimension_10.py",
          "contenido_preview": "\"\"\"\nDIMENSION 10: Validacion-Correccion\n\"\"\"\n\n\nclass DimensionValidacionCorreccion:\n    def __init__(self):\n        self.nombre = \"Validacion-Correccion\"\n        self.magnitud = 0.0\n    \n    def procesar(self, datos):\n        return {\"dimension\": self.nombre, \"magnitud\": 0.5}\n"
        },
        "dimension_11.py": {
          "tipo": "archivo",
          "extension": ".py",
          "tamano_bytes": 273,
          "tamano_humano": "0.27 KB",
          "ruta": "dimensiones\\dimension_11.py",
          "contenido_preview": "\"\"\"\nDIMENSION 11: Conectividad-Red\n\"\"\"\n\n\nclass DimensionConectividadRed:\n    def __init__(self):\n        self.nombre = \"Conectividad-Red\"\n        self.magnitud = 0.0\n    \n    def procesar(self, datos):\n        return {\"dimension\": self.nombre, \"magnitud\": 0.6}\n"
        },
        "dimension_12.py": {
          "tipo": "archivo",
          "extension": ".py",
          "tamano_bytes": 288,
          "tamano_humano": "0.28 KB",
          "ruta": "dimensiones\\dimension_12.py",
          "contenido_preview": "\"\"\"\nDIMENSION 12: Meta-Autoprogramacion\n\"\"\"\n\n\nclass DimensionMetaAutoprogramacion:\n    def __init__(self):\n        self.nombre = \"Meta-Autoprogramacion\"\n        self.magnitud = 0.0\n    \n    def procesar(self, datos):\n        return {\"dimension\": self.nombre, \"magnitud\": 0.1}\n"
        },
        "dimension_2.py": {
          "tipo": "archivo",
          "extension": ".py",
          "tamano_bytes": 269,
          "tamano_humano": "0.26 KB",
          "ruta": "dimensiones\\dimension_2.py",
          "contenido_preview": "\"\"\"\nDIMENSION 2: Espacio-Volumen\n\"\"\"\n\n\nclass DimensionEspacioVolumen:\n    def __init__(self):\n        self.nombre = \"Espacio-Volumen\"\n        self.magnitud = 0.0\n    \n    def procesar(self, datos):\n        return {\"dimension\": self.nombre, \"magnitud\": 0.6}\n"
        },
        "dimension_3.py": {
          "tipo": "archivo",
          "extension": ".py",
          "tamano_bytes": 275,
          "tamano_humano": "0.27 KB",
          "ruta": "dimensiones\\dimension_3.py",
          "contenido_preview": "\"\"\"\nDIMENSION 3: Energia-Potencial\n\"\"\"\n\n\nclass DimensionEnergiaPotencial:\n    def __init__(self):\n        self.nombre = \"Energia-Potencial\"\n        self.magnitud = 0.0\n    \n    def procesar(self, datos):\n        return {\"dimension\": self.nombre, \"magnitud\": 0.3}\n"
        },
        "dimension_4.py": {
          "tipo": "archivo",
          "extension": ".py",
          "tamano_bytes": 284,
          "tamano_humano": "0.28 KB",
          "ruta": "dimensiones\\dimension_4.py",
          "contenido_preview": "\"\"\"\nDIMENSION 4: Informacion-Entropia\n\"\"\"\n\n\nclass DimensionInformacionEntropia:\n    def __init__(self):\n        self.nombre = \"Informacion-Entropia\"\n        self.magnitud = 0.0\n    \n    def procesar(self, datos):\n        return {\"dimension\": self.nombre, \"magnitud\": 0.4}\n"
        },
        "dimension_5.py": {
          "tipo": "archivo",
          "extension": ".py",
          "tamano_bytes": 281,
          "tamano_humano": "0.27 KB",
          "ruta": "dimensiones\\dimension_5.py",
          "contenido_preview": "\"\"\"\nDIMENSION 5: Conciencia-Atencion\n\"\"\"\n\n\nclass DimensionConcienciaAtencion:\n    def __init__(self):\n        self.nombre = \"Conciencia-Atencion\"\n        self.magnitud = 0.0\n    \n    def procesar(self, datos):\n        return {\"dimension\": self.nombre, \"magnitud\": 0.2}\n"
        },
        "dimension_6.py": {
          "tipo": "archivo",
          "extension": ".py",
          "tamano_bytes": 284,
          "tamano_humano": "0.28 KB",
          "ruta": "dimensiones\\dimension_6.py",
          "contenido_preview": "\"\"\"\nDIMENSION 6: Memoria-Persistencia\n\"\"\"\n\n\nclass DimensionMemoriaPersistencia:\n    def __init__(self):\n        self.nombre = \"Memoria-Persistencia\"\n        self.magnitud = 0.0\n    \n    def procesar(self, datos):\n        return {\"dimension\": self.nombre, \"magnitud\": 0.7}\n"
        },
        "dimension_7.py": {
          "tipo": "archivo",
          "extension": ".py",
          "tamano_bytes": 290,
          "tamano_humano": "0.28 KB",
          "ruta": "dimensiones\\dimension_7.py",
          "contenido_preview": "\"\"\"\nDIMENSION 7: Aprendizaje-Adaptacion\n\"\"\"\n\n\nclass DimensionAprendizajeAdaptacion:\n    def __init__(self):\n        self.nombre = \"Aprendizaje-Adaptacion\"\n        self.magnitud = 0.0\n    \n    def procesar(self, datos):\n        return {\"dimension\": self.nombre, \"magnitud\": 0.4}\n"
        },
        "dimension_8.py": {
          "tipo": "archivo",
          "extension": ".py",
          "tamano_bytes": 290,
          "tamano_humano": "0.28 KB",
          "ruta": "dimensiones\\dimension_8.py",
          "contenido_preview": "\"\"\"\nDIMENSION 8: Creatividad-Generacion\n\"\"\"\n\n\nclass DimensionCreatividadGeneracion:\n    def __init__(self):\n        self.nombre = \"Creatividad-Generacion\"\n        self.magnitud = 0.0\n    \n    def procesar(self, datos):\n        return {\"dimension\": self.nombre, \"magnitud\": 0.8}\n"
        },
        "dimension_9.py": {
          "tipo": "archivo",
          "extension": ".py",
          "tamano_bytes": 272,
          "tamano_humano": "0.27 KB",
          "ruta": "dimensiones\\dimension_9.py",
          "contenido_preview": "\"\"\"\nDIMENSION 9: Ejecucion-Accion\n\"\"\"\n\n\nclass DimensionEjecucionAccion:\n    def __init__(self):\n        self.nombre = \"Ejecucion-Accion\"\n        self.magnitud = 0.0\n    \n    def procesar(self, datos):\n        return {\"dimension\": self.nombre, \"magnitud\": 0.9}\n"
        },
        "vector_12d.py": {
          "tipo": "archivo",
          "extension": ".py",
          "tamano_bytes": 3400,
          "tamano_humano": "3.32 KB",
          "ruta": "dimensiones\\vector_12d.py",
          "contenido_preview": "\"\"\"\nSISTEMA VECTORIAL 12D - VERSI√ìN CORREGIDA\nSistema unificado de 12 dimensiones vectoriales\n\"\"\"\n\nimport sys\nimport os\nimport importlib\n\nclass Vector12D:\n    def __init__(self, dimensiones):\n        self.dimensiones = dimensiones\n    \n    def magnitud(self):\n        import math\n        suma = sum(d * d for d in self.dimensiones)\n        return math.sqrt(suma) if suma > 0 else 0.0\n    \n    def __str__(self):\n        dims = \", \".join([f\"{d:.4f}\" for d in self.dimensiones])\n        return f\"Vector12D(mag={self.magnitud():.4f}, dims=[{dims}])\"\n\nclass SistemaVectorial12D:\n    def __init__(self):\n        self.dimensiones = []\n        self._cargar_dimensiones()\n    \n    def _cargar_dimensiones(self):\n        \"\"\"Carga las 12 dimensiones\"\"\"\n        dimensiones_cargadas = 0\n        \n        for i in range(1, 13):\n            try:\n                # Verificar si el archivo existe\n                archivo = f\"dimensiones/dimension_{i}.py\"\n                if not os.path.exists(archivo):\n                    continue\n                \n                # Importar el m√≥dulo\n                modulo_nombre = f\"dimensiones.dimension_{i}\"\n                modulo = importlib.import_module(modulo_nombre)\n                \n                # Buscar clases en el m√≥dulo\n                for nombre in dir(modulo):\n                    obj = getattr(modulo, nombre)\n                    if isinstance(obj, type):\n                        # Crear instancia\n                        instancia = obj()\n                        self.dimensiones.append(instancia)\n                        dimensiones_cargadas += 1\n                        break\n                        \n            except Exception:\n                continue\n        \n        # Si no se cargaron, crear dimensiones simples\n        if dimensiones_cargadas == 0:\n            class DimensionSimple:\n                def __init__(self, idx):\n                    self.idx = idx\n                    self.nombre = f\"Dimensi√≥n_{idx}\"\n                \n                def procesar(self, evento):\n                    return {\"magnitud\": 0.1 * self.idx, \"nombre\": self.nombre}\n            \n            for i in range(1, 13):\n                self.dimensiones.append(DimensionSimple(i))\n    \n    def procesar_evento(self, evento):\n        \"\"\"Procesa un evento a trav√©s de todas las dimensiones\"\"\"\n        valores = []\n        \n        for i, dim in enumerate(self.dimensiones, 1):\n            try:\n                if hasattr(dim, 'procesar'):\n                    resultado = dim.procesar(evento)\n                    if isinstance(resultado, dict) and 'magnitud' in resultado:\n                        valores.append(float(resultado['magnitud']))\n                    elif isinstance(resultado, (int, float)):\n                        valores.append(float(resultado))\n                    else:\n                        valores.append(0.1 * i)\n                else:\n                    valores.append(0.1 * i)\n            except:\n                valores.append(0.05 * i)\n        \n        # Asegurar 12 valores\n        while len(valores) < 12:\n            valores.append(0.0)\n        \n        if len(valores) > 12:\n            valores = valores[:12]\n        \n        return Vector12D(valores)\n    \n    def obtener_numero_dimensiones(self):\n        return len(self.dimensiones)\n"
        },
        "vector_12d.py.backup": {
          "tipo": "archivo",
          "extension": ".backup",
          "tamano_bytes": 10474,
          "tamano_humano": "10.23 KB",
          "ruta": "dimensiones\\vector_12d.py.backup",
          "contenido_preview": null
        }
      }
    },
    "0": {
      "tipo": "archivo",
      "extension": "sin_extension",
      "tamano_bytes": 0,
      "tamano_humano": "0.00 KB",
      "ruta": "0",
      "contenido_preview": null
    },
    "analizar_carpeta.py": {
      "tipo": "archivo",
      "extension": ".py",
      "tamano_bytes": 9591,
      "tamano_humano": "9.37 KB",
      "ruta": "analizar_carpeta.py",
      "contenido_preview": "import os\nimport json\nimport sys\nfrom pathlib import Path\nfrom datetime import datetime\n\ndef analizar_carpeta(ruta_carpeta, max_contenido_chars=5000):\n    \"\"\"\n    Analiza una carpeta y genera un reporte estructurado\n    \"\"\"\n    ruta = Path(ruta_carpeta)\n    \n    if not ruta.exists():\n        return {\"error\": f\"La carpeta no existe: {ruta_carpeta}\"}\n    \n    if not ruta.is_dir():\n        return {\"error\": f\"La ruta no es una carpeta: {ruta_carpeta}\"}\n    \n    reporte = {\n        \"fecha_analisis\": datetime.now().isoformat(),\n        \"ruta_carpeta\": str(ruta.absolute()),\n        \"estructura\": {},\n        \"estadisticas\": {\n            \"total_archivos\": 0,\n            \"total_carpetas\": 0,\n            \"tamano_total_bytes\": 0,\n            \"extensiones\": {}\n        },\n        \"contenidos_importantes\": {}\n    }\n    \n    # Funci√≥n recursiva para analizar\n    def analizar_recursivo(directorio, nivel_max=3, nivel_actual=0):\n        if nivel_actual >= nivel_max:\n            return {\"_profundidad_maxima\": f\"Profundidad m√°xima ({nivel_max}) alcanzada\"}\n        \n        estructura = {}\n        \n        try:\n            items = list(directorio.iterdir())\n            for item in sorted(items, key=lambda x: (not x.is_dir(), x.name.lower())):\n                nombre = item.name\n                \n                if item.is_dir():\n                    reporte[\"estadisticas\"][\"total_carpetas\"] += 1\n                    estructura[nombre] = {\n                        \"tipo\": \"carpeta\",\n                        \"ruta\": str(item.relative_to(ruta)),\n                        \"contenido\": analizar_recursivo(item, nivel_max, nivel_actual + 1)\n                    }\n                else:\n                    reporte[\"estadisticas\"][\"total_archivos\"] += 1\n                    \n                    # Obtener extensi√≥n\n                    ext = item.suffix.lower() if item.suffix else \"sin_extension\"\n                    reporte[\"estadisticas\"][\"extensiones\"][ext] = reporte[\"estadisticas\"][\"extensiones\"].get(ext, 0) + 1\n                    \n                    # Obtener tama√±o\n                    tamano = item.stat().st_size\n                    reporte[\"estadisticas\"][\"tamano_total_bytes\"] += tamano\n                    \n                    # Leer contenido de archivos de texto peque√±os\n                    contenido = \"\"\n                    if tamano < 100000:  # Archivos menores a 100KB\n                        try:\n                            if ext in ['.txt', '.py', '.js', '.json', '.xml', '.html', '.css', '.md', '.csv', '.log', '.ps1', '.bat', '.cmd', '.ini', '.config', '.inf', '.cfg']:\n                                with open(item, 'r', encoding='utf-8', errors='ignore') as f:\n                                    contenido_preview = f.read(5000)\n                                    if contenido_preview.strip():\n                                        contenido = contenido_preview\n                        except:\n                            contenido = \"[No se pudo leer el contenido]\"\n                    \n                    estructura[nombre] = {\n                        \"tipo\": \"archivo\",\n                        \"extension\": ext,\n                        \"tamano_bytes\": tamano,\n                        \"tamano_humano\": f\"{tamano / 1024:.2f} KB\" if tamano < 1024*1024 else f\"{tamano / (1024*1024):.2f} MB\",\n                        \"ruta\": str(item.relative_to(ruta)),\n                        \"contenido_preview\": contenido if contenido else None\n                    }\n                    \n        except PermissionError:\n            estructura[\"_error\"] = \"Permiso denegado\"\n        except Exception as e:\n            estructura[\"_error\"] = str(e)\n        \n        return estructura\n    \n    # Analizar la carpeta principal\n    reporte[\"estructura\"] = analizar_recursivo(ruta)\n    \n    return reporte\n\ndef generar_reporte_html(reporte, archivo_salida=\"reporte_carpeta.html\"):\n    \"\"\"Genera un reporte HTML legible\"\"\"\n    html = f\"\"\"\n    <!DOCTYPE html>\n    <html>\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>Reporte de Carpeta: {reporte['ruta_carpeta']}</title>\n        <style>\n            body {{ font-family: Arial, sans-serif; margin: 20px; }}\n            .seccion {{ margin: 20px 0; padding: 15px; border: 1px solid #ddd; }}\n            .archivo {{ margin: 5px 0; padding: 5px; background: #f5f5f5; }}\n            .carpeta {{ margin: 10px 0; padding: 10px; background: #e8f4fc; }}\n            .contenido {{ background: #fff8dc; padding: 10px; margin: 5px 0; font-family: monospace; }}\n            .estadisticas {{ background: #f0f0f0; padding: 15px; }}\n        </style>\n    </head>\n    <body>\n        <h1>üìÅ Reporte de Carpeta</h1>\n        <div class=\"seccion\">\n            <h2>üìä Informaci√≥n General</h2>\n            <p><strong>Ruta:</strong> {reporte['ruta_carpeta']}</p>\n            <p><strong>Fecha de an√°lisis:</strong> {reporte['fecha_analisis']}</p>\n        </div>\n        \n        <div class=\"seccion estadisticas\">\n            <h2>üìà Estad√≠sticas</h2>\n            <p"
    },
    "crear_vector.py": {
      "tipo": "archivo",
      "extension": ".py",
      "tamano_bytes": 11087,
      "tamano_humano": "10.83 KB",
      "ruta": "crear_vector.py",
      "contenido_preview": "# Script para crear vector_12d.py correctamente\nimport os\n\n# El c√≥digo nuevo completo\ncodigo_nuevo = '''\"\"\"\nSISTEMA VECTORIAL 12D - VERSI√ìN CORREGIDA\nSistema unificado de 12 dimensiones vectoriales\n\"\"\"\nimport json\nimport time\nimport importlib\nimport sys\nimport os\nfrom typing import List, Dict, Any\n\n# Asegurar que podemos importar desde el directorio actual\nsys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nclass Vector12D:\n    \"\"\"Representa un vector en 12 dimensiones\"\"\"\n    def __init__(self, dimensiones: List[float]):\n        self.dimensiones = dimensiones\n        self.timestamp = time.time()\n        \n    def magnitud(self) -> float:\n        \"\"\"Calcula la magnitud del vector\"\"\"\n        import math\n        suma_cuadrados = sum(d * d for d in self.dimensiones)\n        return math.sqrt(suma_cuadrados) if suma_cuadrados > 0 else 0.0\n    \n    def normalizar(self) -> 'Vector12D':\n        \"\"\"Devuelve una versi√≥n normalizada del vector\"\"\"\n        mag = self.magnitud()\n        if mag > 0:\n            return Vector12D([d / mag for d in self.dimensiones])\n        return Vector12D([0.0] * 12)\n    \n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convierte el vector a diccionario\"\"\"\n        return {\n            'dimensiones': self.dimensiones,\n            'magnitud': self.magnitud(),\n            'timestamp': self.timestamp,\n            'dimensiones_count': len(self.dimensiones)\n        }\n    \n    def __str__(self) -> str:\n        \"\"\"Representaci√≥n en texto del vector\"\"\"\n        dim_str = \", \".join([f\"{d:.4f}\" for d in self.dimensiones])\n        return f\"Vector12D(mag={self.magnitud():.4f}, dims=[{dim_str}])\"\n\nclass SistemaVectorial12D:\n    \"\"\"Sistema principal que maneja las 12 dimensiones\"\"\"\n    \n    def __init__(self):\n        print(\"[Vector12D] Inicializando sistema vectorial...\")\n        self.dimensiones = []\n        self._cargar_dimensiones()\n        print(f\"[Vector12D] Sistema inicializado con {len(self.dimensiones)} dimensiones\")\n    \n    def _cargar_dimensiones(self):\n        \"\"\"Carga din√°micamente las 12 dimensiones\"\"\"\n        dimensiones_cargadas = 0\n        \n        for i in range(1, 13):\n            try:\n                # Construir el nombre del m√≥dulo\n                modulo_nombre = f\"dimensiones.dimension_{i}\"\n                \n                # Verificar si el archivo existe\n                archivo_dimension = f\"dimensiones/dimension_{i}.py\"\n                if not os.path.exists(archivo_dimension):\n                    print(f\"  [Vector12D] Advertencia: No existe {archivo_dimension}\")\n                    continue\n                \n                # Importar el m√≥dulo\n                modulo = importlib.import_module(modulo_nombre)\n                \n                # Buscar la clase principal en el m√≥dulo\n                clase_dimension = None\n                for nombre_clase in dir(modulo):\n                    # Filtrar nombres que contengan 'Dimension' o 'Dim'\n                    if 'Dimension' in nombre_clase or 'Dim' in nombre_clase:\n                        obj = getattr(modulo, nombre_clase)\n                        if isinstance(obj, type):  # Es una clase\n                            clase_dimension = obj\n                            break\n                \n                if clase_dimension:\n                    # Crear instancia de la dimensi√≥n\n                    instancia = clase_dimension()\n                    self.dimensiones.append(instancia)\n                    dimensiones_cargadas += 1\n                    print(f\"  [Vector12D] ‚úì Dimensi√≥n {i} cargada: {clase_dimension.__name__}\")\n                else:\n                    print(f\"  [Vector12D] ‚úó No se encontr√≥ clase en dimensi√≥n {i}\")\n                    \n            except ImportError as e:\n                print(f\"  [Vector12D] ‚úó Error importando dimensi√≥n {i}: {str(e)[:100]}\")\n            except Exception as e:\n                print(f\"  [Vector12D] ‚úó Error cargando dimensi√≥n {i}: {str(e)[:100]}\")\n        \n        # Si no se cargaron dimensiones, crear dimensiones por defecto\n        if dimensiones_cargadas == 0:\n            print(\"  [Vector12D] ‚ö†Ô∏è Creando dimensiones por defecto...\")\n            self._crear_dimensiones_por_defecto()\n    \n    def _crear_dimensiones_por_defecto(self):\n        \"\"\"Crea dimensiones b√°sicas por defecto si no se pueden cargar las reales\"\"\"\n        class DimensionBase:\n            def __init__(self, nombre, indice):\n                self.nombre = nombre\n                self.indice = indice\n                self.contador = 0\n            \n            def procesar(self, evento):\n                self.contador += 1\n                # Valor simple basado en el √≠ndice y longitud del evento\n                valor = 0.1 * self.indice + 0.01 * len(str(evento))\n                return {'magnitud': valor, 'procesado': True, 'dimension': self.indice}\n        \n        nombres = [\n            \"Tiempo-Entrop√≠a\", \"Espacio-Volumen\", \"Energ√≠a-Potencial\",\n            \"Informaci√≥n-Entrop√≠a\", \"Conciencia-Atenci√≥n\", "
    },
    "crear_zip.py": {
      "tipo": "archivo",
      "extension": ".py",
      "tamano_bytes": 1139,
      "tamano_humano": "1.11 KB",
      "ruta": "crear_zip.py",
      "contenido_preview": "import zipfile\nimport os\n\n# Archivos a incluir en el ZIP\nfiles = [\n    'INSTALAR.bat',\n    'vecta_self_install.py', \n    'vecta_12d_launcher.py',\n    'paquete_vecta.pkg'\n]\n\nzip_name = 'VECTA_12D_Automatico.zip'\n\nprint(\"Creando ZIP de VECTA 12D...\")\nprint(\"-\" * 40)\n\n# Crear archivo ZIP\nwith zipfile.ZipFile(zip_name, 'w', zipfile.ZIP_DEFLATED) as zipf:\n    for file in files:\n        if os.path.exists(file):\n            zipf.write(file)\n            print(f'‚úì A√±adido: {file}')\n        else:\n            print(f'‚úó No encontrado: {file}')\n\n# Verificar\nsize = os.path.getsize(zip_name)\nprint(\"\\n\" + \"=\" * 40)\nprint(f'‚úÖ ZIP creado: {zip_name}')\nprint(f'üì¶ Tama√±o: {size} bytes = {size/1024/1024:.2f} MB')\nprint(f'üìç Ubicaci√≥n: {os.path.abspath(zip_name)}')\nprint(\"=\" * 40)\nprint(\"\\n¬°Listo! Este ZIP contiene VECTA 12D completo.\")\nprint(\"Solo extrae y ejecuta INSTALAR.bat como administrador.\")\n\n# Verificar contenido\nprint(\"\\nContenido del ZIP:\")\nwith zipfile.ZipFile(zip_name, 'r') as zipf:\n    for info in zipf.infolist():\n        print(f'  ‚Ä¢ {info.filename} ({info.file_size} bytes)')"
    },
    "create_vecta_package.py": {
      "tipo": "archivo",
      "extension": ".py",
      "tamano_bytes": 5778,
      "tamano_humano": "5.64 KB",
      "ruta": "create_vecta_package.py",
      "contenido_preview": "\"\"\"\nCrea el paquete .pkg con todos los archivos de VECTA 12D\nVersi√≥n simplificada para evitar errores de sintaxis\n\"\"\"\nimport os\nimport zipfile\nimport json\n\ndef create_pkg_file(output_file=\"paquete_vecta.pkg\"):\n    \"\"\"Crea el archivo .pkg con todos los archivos\"\"\"\n    \n    # Archivos esenciales para VECTA 12D\n    package_files = {\n        # Archivos ra√≠z\n        \"README.txt\": \"VECTA 12D - Sistema Autoprogramable de 12 Dimensiones\\n\\nInstalaci√≥n: Ejecuta INSTALAR.bat como administrador\\nUso: Haz doble clic en VECTA 12D del escritorio\",\n        \n        \"LICENSE.txt\": \"LICENCIA VECTA 12D - Software libre para uso personal\",\n        \n        \"config.json\": json.dumps({\n            \"version\": \"12D.1.0.0\",\n            \"dimensions\": 12,\n            \"auto_update\": True\n        }, indent=2),\n        \n        # Core del sistema\n        \"core/__init__.py\": \"# Paquete core de VECTA 12D\\n\",\n        \n        \"core/vecta_12d_core.py\": '''# vecta_12d_core.py - N√∫cleo principal\nimport sys\nimport os\n\nclass VECTA_12D_Core:\n    def __init__(self):\n        self.mode = \"local\"\n    \n    def process(self, input_text):\n        return f\"VECTA 12D: Procesando '{input_text}' en modo {self.mode}\"\n    \n    def start_gui(self):\n        try:\n            from interfaz.vecta_gui_secure import VECTA_GUI\n            import tkinter as tk\n            root = tk.Tk()\n            app = VECTA_GUI(root)\n            root.mainloop()\n        except:\n            print(\"GUI no disponible, usando consola\")\n            self._start_console()\n    \n    def _start_console(self):\n        print(\"Modo consola 12D activado\")\n        while True:\n            cmd = input(\"12D> \")\n            if cmd.lower() in ['exit', 'quit', 'salir']:\n                break\n            print(self.process(cmd))''',\n        \n        # Interfaz gr√°fica b√°sica\n        \"interfaz/__init__.py\": \"# Interfaz de usuario\\n\",\n        \n        \"interfaz/vecta_gui_secure.py\": '''# vecta_gui_secure.py - GUI principal\nimport tkinter as tk\nfrom tkinter import ttk, scrolledtext\n\nclass VECTA_GUI:\n    def __init__(self, root):\n        self.root = root\n        self.setup_gui()\n    \n    def setup_gui(self):\n        self.root.title(\"VECTA 12D\")\n        self.root.geometry(\"800x600\")\n        \n        # √Årea de chat\n        self.text_area = scrolledtext.ScrolledText(self.root, wrap=tk.WORD)\n        self.text_area.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # Entrada\n        self.input_frame = ttk.Frame(self.root)\n        self.input_frame.pack(fill=tk.X, padx=10, pady=5)\n        \n        self.input_var = tk.StringVar()\n        self.input_entry = ttk.Entry(self.input_frame, textvariable=self.input_var)\n        self.input_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 5))\n        \n        self.send_btn = ttk.Button(self.input_frame, text=\"Enviar\", command=self.send_message)\n        self.send_btn.pack(side=tk.RIGHT)\n        \n        self.input_entry.bind(\"<Return>\", lambda e: self.send_message())\n        \n        self.text_area.insert(tk.END, \"üåÄ VECTA 12D iniciado\\\\n\")\n        self.text_area.insert(tk.END, \"Escribe 'hola' para comenzar\\\\n\\\\n\")\n    \n    def send_message(self):\n        message = self.input_var.get()\n        if message:\n            self.text_area.insert(tk.END, f\"T√∫: {message}\\\\n\")\n            self.input_var.set(\"\")\n            \n            # Procesar mensaje\n            if message.lower() == 'hola':\n                response = \"¬°Hola! Soy VECTA 12D, tu sistema autoprogramable\"\n            elif '12d' in message.lower():\n                response = \"Sistema de 12 Dimensiones Vectoriales activo\"\n            else:\n                response = f\"Procesando: {message}\"\n            \n            self.text_area.insert(tk.END, f\"VECTA: {response}\\\\n\\\\n\")\n            self.text_area.see(tk.END)\n\ndef main():\n    root = tk.Tk()\n    app = VECTA_GUI(root)\n    root.mainloop()\n\nif __name__ == \"__main__\":\n    main()''',\n        \n        # Dimensiones b√°sicas\n        \"dimensiones/__init__.py\": \"# Paquete de dimensiones 12D\\n\",\n        \n        \"dimensiones/d1_temporal.py\": \"# Dimensi√≥n 1: Temporal\\\\nclass TemporalDimension:\\\\n    def process(self, data):\\\\n        return {'dimension': 1}\",\n        \n        \"dimensiones/d2_espacial.py\": \"# Dimensi√≥n 2: Espacial\\\\nclass SpatialDimension:\\\\n    def process(self, data):\\\\n        return {'dimension': 2}\",\n        \n        # Scripts\n        \"scripts/__init__.py\": \"# Scripts auxiliares\\n\",\n        \n        \"scripts/initial_setup.py\": '''# initial_setup.py\nimport json\nimport os\n\ndef run_setup():\n    print(\"Configuraci√≥n inicial VECTA 12D\")\n    os.makedirs(\"data\", exist_ok=True)\n    os.makedirs(\"logs\", exist_ok=True)\n    \n    config = {\"setup_complete\": True}\n    with open(\"data/setup.json\", 'w') as f:\n        json.dump(config, f, indent=2)\n    \n    print(\"‚úÖ Configuraci√≥n completada\")\n\nif __name__ == \"__main__\":\n    run_setup()''',\n        \n        # Datos b√°sicos\n        \"data/local_knowledge.json\": json.dumps({\n            \"greetings\": [\"Hola\","
    },
    "INSTALAR.bat": {
      "tipo": "archivo",
      "extension": ".bat",
      "tamano_bytes": 434,
      "tamano_humano": "0.42 KB",
      "ruta": "INSTALAR.bat",
      "contenido_preview": "@echo off\ntitle VECTA 12D - Instalador\necho ====================================\necho    VECTA 12D - Sistema 12D\necho ====================================\necho.\necho [1/2] Verificando Python...\npython --version >nul 2>&1\nif errorlevel 1 (\n    echo Error: Python no encontrado\n    echo Instala Python desde python.org\n    pause\n    exit /b 1\n)\n\necho [2/2] Iniciando VECTA 12D...\necho.\npython vecta_launcher.py\npause\n"
    },
    "integrar_meta_vecta.py": {
      "tipo": "archivo",
      "extension": ".py",
      "tamano_bytes": 50411,
      "tamano_humano": "49.23 KB",
      "ruta": "integrar_meta_vecta.py",
      "contenido_preview": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nVECTA 12D - SISTEMA DE AUTO-INCORPORACI√ìN\n=========================================\nScript autom√°tico para integrar la especificaci√≥n META-VECTA 1.0\nSigue los principios VECTA: auto-contenido, auto-verificaci√≥n, auto-reparaci√≥n\n\"\"\"\n\nimport os\nimport sys\nimport shutil\nimport time\nimport hashlib\nimport json\nfrom datetime import datetime\n\nprint(\"\\n\" + \"=\"*80)\nprint(\"‚ö° VECTA 12D - AUTO-INCORPORACI√ìN META-VECTA 1.0\")\nprint(\"=\"*80)\nprint(f\"üìÖ Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\nprint(f\"üìÅ Directorio: {os.getcwd()}\")\nprint(\"=\"*80)\n\n# ==================== FUNCIONES DE AUTO-VERIFICACI√ìN ====================\n\ndef verificar_estructura():\n    \"\"\"Verifica la estructura b√°sica del proyecto\"\"\"\n    print(\"\\n[1/8] üîç VERIFICANDO ESTRUCTURA DEL PROYECTO...\")\n    \n    requeridos = {\n        'core/': 'Directorio del n√∫cleo',\n        'dimensiones/': 'Directorio de dimensiones',\n        'vecta_launcher.py': 'Lanzador principal',\n        'core/vecta_12d_core.py': 'N√∫cleo VECTA 12D',\n        'dimensiones/vector_12d.py': 'Sistema vectorial 12D'\n    }\n    \n    faltantes = []\n    for ruta, descripcion in requeridos.items():\n        if os.path.exists(ruta):\n            print(f\"  ‚úì {ruta:30} {descripcion}\")\n        else:\n            print(f\"  ‚úó {ruta:30} {descripcion} - NO ENCONTRADO\")\n            faltantes.append(ruta)\n    \n    if faltantes:\n        print(f\"\\n‚ö†Ô∏è  ADVERTENCIA: Faltan {len(faltantes)} elementos cr√≠ticos\")\n        return False\n    else:\n        print(\"  ‚úÖ Estructura verificada correctamente\")\n        return True\n\ndef crear_backup(ruta_archivo):\n    \"\"\"Crea un backup de un archivo con timestamp\"\"\"\n    if os.path.exists(ruta_archivo):\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        backup_ruta = f\"{ruta_archivo}.backup_{timestamp}\"\n        try:\n            shutil.copy2(ruta_archivo, backup_ruta)\n            return backup_ruta\n        except:\n            return None\n    return None\n\ndef calcular_hash(contenido):\n    \"\"\"Calcula el hash MD5 de un contenido\"\"\"\n    return hashlib.md5(contenido.encode('utf-8')).hexdigest()\n\n# ==================== INCORPORACI√ìN META-VECTA ====================\n\ndef incorporar_meta_vecta():\n    \"\"\"Incorpora el sistema META-VECTA al proyecto\"\"\"\n    print(\"\\n[2/8] üöÄ INCORPORANDO ESPECIFICACI√ìN META-VECTA...\")\n    \n    # C√≥digo completo del sistema META-VECTA\n    META_VECTA_CODE = '''#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nMETA-VECTA CORE - Especificaci√≥n Ejecutable 1.0\n===============================================\nN√∫cleo filos√≥fico y l√≥gico del sistema VECTA\nBasado en la especificaci√≥n unificada de Rafael Porley\n\"\"\"\n\nimport json\nimport time\nimport math\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Any, Tuple, Optional\nfrom enum import Enum\nimport hashlib\n\n# ==================== SECCI√ìN 1 - META-VECTA CORE ====================\n\nclass VECTAPrinciple(Enum):\n    \"\"\"Principios inmutables de META-VECTA\"\"\"\n    ALWAYS_DECIDE = \"P1: ALWAYS_DECIDE\"\n    FINITE_TIME_COLLAPSE = \"P2: FINITE_TIME_COLLAPSE\"\n    NO_COMPLEXITY_WITHOUT_GAIN = \"P3: NO_COMPLEXITY_WITHOUT_GAIN\"\n    FULL_AUDITABILITY = \"P4: FULL_AUDITABILITY\"\n    SEPARATION_OF_LAYERS = \"P5: SEPARATION_OF_LAYERS\"\n\nclass MetaVECTA:\n    \"\"\"N√∫cleo inmutable de principios META-VECTA\"\"\"\n    \n    def __init__(self):\n        self.immutable = True\n        self.creation_time = time.time()\n        self.creator = \"Rafael Porley\"\n        self.version = \"1.0\"\n        self.purpose = \"Portable definition to teach any IA or PC runtime how VECTA works\"\n        \n        # Principios fundamentales\n        self.principles = {\n            VECTAPrinciple.ALWAYS_DECIDE: \"No non-execution allowed\",\n            VECTAPrinciple.FINITE_TIME_COLLAPSE: \"Decisions must resolve in finite time\",\n            VECTAPrinciple.NO_COMPLEXITY_WITHOUT_GAIN: \"Complexity must be justified\",\n            VECTAPrinciple.FULL_AUDITABILITY: \"Every change is logged\",\n            VECTAPrinciple.SEPARATION_OF_LAYERS: \"Language ‚â† Intention ‚â† Execution\"\n        }\n        \n        # Operador Salom√≥n\n        self.operator_salomon = {\n            \"description\": \"Forced decision under undecidable superposition\",\n            \"rule\": \"IF (SUPERPOSITION_TIME > T_MAX) THEN SELECT ACTION THAT MINIMIZES IRREVERSIBLE_DAMAGE\",\n            \"t_max\": 5.0  # 5 segundos m√°ximo para decisiones\n        }\n        \n        # M√©trica de validez global\n        self.validity_metric = {\n            \"requirements\": {\n                \"delta_information_density\": \"> 0\",\n                \"delta_decision_time\": \"<= 0\",\n                \"delta_accumulated_error\": \"<= epsilon\"\n            },\n            \"epsilon\": 0.001,\n            \"failure_action\": \"ROLLBACK_IMMEDIATE\"\n        }\n        \n        # Log de auditor√≠a\n        self.audit_log = []\n        self._log_event(\"META_VECTA_CORE_INITIALIZED\", {\n            \"timestamp\": self.creation_time,\n            \"version\": self.version,\n            \"creator\": self.creator\n        "
    },
    "paquete_vecta.pkg": {
      "tipo": "archivo",
      "extension": ".pkg",
      "tamano_bytes": 5938,
      "tamano_humano": "5.80 KB",
      "ruta": "paquete_vecta.pkg",
      "contenido_preview": null
    },
    "prueba_vecta.py": {
      "tipo": "archivo",
      "extension": ".py",
      "tamano_bytes": 448,
      "tamano_humano": "0.44 KB",
      "ruta": "prueba_vecta.py",
      "contenido_preview": "import sys \nimport os \nsys.path.insert(0, \".\") \nprint(\"Probando VECTA 12D...\") \ntry: \n    from core.vecta_12d_core import VECTA_12D_Core \n    v = VECTA_12D_Core() \n    print(\"? Sistema cargado\") \n    res = v.procesar(\"Hola mundo\") \n    if res[\"exito\"]: \n        print(f\"? Vector creado - Magnitud: {res['magnitud']:.4f}\") \n    else: \n        print(f\"? Error: {res.get('error')}\") \nexcept Exception as e: \n    print(f\"? Error: {e}\") \n"
    },
    "python fix_simple.py": {
      "tipo": "archivo",
      "extension": ".py",
      "tamano_bytes": 453,
      "tamano_humano": "0.44 KB",
      "ruta": "python fix_simple.py",
      "contenido_preview": "python -c \"\nwith open('vecta_launcher.py', 'r', encoding='utf-8') as f:\n    contenido = f.read()\n    \nif 'elif opcion == \\\"7\\\":' in contenido and 'Salir' in contenido:\n    print('OK: Opcion 7 es Salir')\nelse:\n    print('ERROR: No se encontro opcion 7 para Salir')\n    \nif 'opcion == \\\"6\\\"' in contenido and 'META-VECTA' in contenido:\n    print('OK: Opcion 6 es META-VECTA')\nelse:\n    print('ADVERTENCIA: Opcion 6 puede no ser META-VECTA')\n\""
    },
    "registro_incorporacion.json": {
      "tipo": "archivo",
      "extension": ".json",
      "tamano_bytes": 301,
      "tamano_humano": "0.29 KB",
      "ruta": "registro_incorporacion.json",
      "contenido_preview": "{\n  \"fecha\": \"2025-12-25T18:53:47.185366\",\n  \"version\": \"1.0\",\n  \"especificacion\": \"META-VECTA\",\n  \"archivos_creados\": [\n    \"core/meta_vecta.py\"\n  ],\n  \"archivos_modificados\": [\n    \"vecta_launcher.py\"\n  ],\n  \"hash_sistema\": \"c45d7b1a7f82a90363d9f205f65d43c5\",\n  \"estado\": \"INCORPORADO\"\n}"
    },
    "reparar_menu.py": {
      "tipo": "archivo",
      "extension": ".py",
      "tamano_bytes": 9514,
      "tamano_humano": "9.29 KB",
      "ruta": "reparar_menu.py",
      "contenido_preview": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nVECTA 12D - AUTO-REPARACI√ìN DE MEN√ö\nScript autom√°tico para corregir el error de sintaxis en el men√∫\n\"\"\"\n\nimport os\nimport sys\nimport time\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"üîß VECTA 12D - AUTO-REPARACI√ìN DE MEN√ö\")\nprint(\"=\"*70)\n\ndef reparar_menu_lanzador():\n    \"\"\"Repara el error de sintaxis en vecta_launcher.py\"\"\"\n    \n    archivo = \"vecta_launcher.py\"\n    \n    if not os.path.exists(archivo):\n        print(f\"‚ùå Archivo no encontrado: {archivo}\")\n        return False\n    \n    print(f\"üìñ Leyendo {archivo}...\")\n    \n    try:\n        with open(archivo, 'r', encoding='utf-8') as f:\n            lineas = f.readlines()\n        \n        print(f\"‚úÖ Le√≠das {len(lineas)} l√≠neas\")\n        \n        # Buscar el men√∫ problem√°tico\n        menu_encontrado = False\n        lineas_reparadas = []\n        \n        for i, linea in enumerate(lineas):\n            if \"6. Sistema META-VECTA (Nuevo)\" in linea and not linea.strip().startswith(\"print\"):\n                print(f\"‚ö†Ô∏è  L√≠nea {i+1} con error: {linea.strip()}\")\n                # Corregir la l√≠nea - agregar print\n                linea_corregida = '    print(\"6. Sistema META-VECTA (Nuevo)\")\\n'\n                lineas_reparadas.append(linea_corregida)\n                menu_encontrado = True\n                print(f\"‚úÖ L√≠nea corregida: {linea_corregida.strip()}\")\n            elif \"7. Salir del sistema\" in linea and not linea.strip().startswith(\"print\"):\n                print(f\"‚ö†Ô∏è  L√≠nea {i+1} con error: {linea.strip()}\")\n                # Corregir la l√≠nea - agregar print\n                linea_corregida = '    print(\"7. Salir del sistema\")\\n'\n                lineas_reparadas.append(linea_corregida)\n                print(f\"‚úÖ L√≠nea corregida: {linea_corregida.strip()}\")\n            else:\n                lineas_reparadas.append(linea)\n        \n        if not menu_encontrado:\n            # Intentar otro m√©todo: buscar la funci√≥n mostrar_menu_principal\n            print(\"üîç Buscando funci√≥n mostrar_menu_principal...\")\n            \n            # Unir las l√≠neas para buscar mejor\n            contenido = ''.join(lineas)\n            \n            # Definir el men√∫ corregido\n            menu_corregido = '''def mostrar_menu_principal():\n    \"\"\"Muestra el men√∫ principal de opciones.\"\"\"\n    print(\"\\\\n\" + \"‚ïê\" * 70)\n    print(\"MEN√ö PRINCIPAL - VECTA 12D\")\n    print(\"‚ïê\" * 70)\n    print(\"1. Procesar texto/comando\")\n    print(\"2. Ver estado del sistema\")\n    print(\"3. Probar dimensiones individuales\")\n    print(\"4. Ejecutar autodiagn√≥stico\")\n    print(\"5. Generar vector 12D aleatorio\")\n    print(\"6. Sistema META-VECTA (Nuevo)\")\n    print(\"7. Salir del sistema\")\n    print(\"‚ïê\" * 70)\n'''\n            \n            # Reemplazar la funci√≥n completa\n            if 'def mostrar_menu_principal():' in contenido:\n                # Encontrar inicio y fin de la funci√≥n\n                inicio = contenido.find('def mostrar_menu_principal():')\n                # Buscar el pr√≥ximo def o return\n                fin = contenido.find('\\ndef ', inicio + 1)\n                if fin == -1:\n                    fin = len(contenido)\n                \n                # Crear nuevo contenido\n                nuevo_contenido = contenido[:inicio] + menu_corregido + contenido[fin:]\n                lineas_reparadas = nuevo_contenido.splitlines(keepends=True)\n                print(\"‚úÖ Funci√≥n mostrar_menu_principal reemplazada completamente\")\n            else:\n                print(\"‚ùå No se encontr√≥ la funci√≥n del men√∫\")\n                return False\n        \n        # Escribir el archivo reparado\n        with open(archivo, 'w', encoding='utf-8') as f:\n            f.writelines(lineas_reparadas)\n        \n        print(f\"‚úÖ Archivo reparado: {archivo}\")\n        print(f\"üìè Nuevo tama√±o: {os.path.getsize(archivo)} bytes\")\n        \n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error al reparar: {e}\")\n        return False\n\ndef verificar_reparacion():\n    \"\"\"Verifica que la reparaci√≥n fue exitosa\"\"\"\n    \n    archivo = \"vecta_launcher.py\"\n    \n    try:\n        # Verificar sintaxis Python\n        print(\"\\nüîç Verificando sintaxis Python...\")\n        import ast\n        with open(archivo, 'r', encoding='utf-8') as f:\n            contenido = f.read()\n        ast.parse(contenido)  # Esto lanza SyntaxError si hay error\n        print(\"‚úÖ Sintaxis Python v√°lida\")\n        \n        # Verificar que el men√∫ est√© correcto\n        if 'print(\"6. Sistema META-VECTA (Nuevo)\")' in contenido:\n            print(\"‚úÖ Men√∫ META-VECTA presente\")\n        else:\n            print(\"‚ö†Ô∏è  Men√∫ META-VECTA no encontrado\")\n        \n        # Verificar que no haya l√≠neas problem√°ticas\n        lineas_problematicas = []\n        for i, linea in enumerate(contenido.split('\\n'), 1):\n            if \"6. Sistema META-VECTA (Nuevo)\" in linea and not linea.strip().startswith(\"print\"):\n                lineas_problematicas.append(i)\n            if \"7. Salir del sistema\" in linea and not linea.strip().startswith(\"print\"):\n                "
    },
    "reparar_opcion6.py": {
      "tipo": "archivo",
      "extension": ".py",
      "tamano_bytes": 14702,
      "tamano_humano": "14.36 KB",
      "ruta": "reparar_opcion6.py",
      "contenido_preview": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nVECTA 12D - REPARACI√ìN DE OPCI√ìN 6 (META-VECTA)\nCorrige el procesamiento de la opci√≥n 6 en el lanzador\n\"\"\"\n\nimport os\nimport sys\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"üîß VECTA 12D - REPARACI√ìN DE OPCI√ìN 6 (META-VECTA)\")\nprint(\"=\"*70)\n\ndef reparar_opcion6():\n    \"\"\"Repara espec√≠ficamente la opci√≥n 6 del lanzador\"\"\"\n    \n    archivo = \"vecta_launcher.py\"\n    \n    if not os.path.exists(archivo):\n        print(f\"‚ùå Archivo no encontrado: {archivo}\")\n        return False\n    \n    print(f\"üìñ Leyendo {archivo}...\")\n    \n    try:\n        with open(archivo, 'r', encoding='utf-8') as f:\n            contenido = f.read()\n        \n        print(f\"‚úÖ Le√≠das {len(contenido)} caracteres\")\n        \n        # Buscar la funci√≥n procesar_opcion\n        if 'def procesar_opcion(' not in contenido:\n            print(\"‚ùå No se encontr√≥ la funci√≥n procesar_opcion\")\n            return False\n        \n        # Extraer la funci√≥n completa\n        inicio = contenido.find('def procesar_opcion(')\n        # Encontrar el final de la funci√≥n (pr√≥xima funci√≥n o fin)\n        funciones = ['\\ndef ', '\\nclass ', '\\nasync def ']\n        fin = len(contenido)\n        for func in funciones:\n            idx = contenido.find(func, inicio + 1)\n            if idx != -1 and idx < fin:\n                fin = idx\n        \n        funcion_completa = contenido[inicio:fin]\n        \n        print(\"üîç Analizando funci√≥n procesar_opcion...\")\n        \n        # Verificar si ya tiene la opci√≥n 6 correcta\n        if 'opcion == \"6\"' in funcion_completa and 'Sistema META-VECTA' in funcion_completa:\n            print(\"‚úÖ La opci√≥n 6 ya est√° configurada para META-VECTA\")\n            return True\n        \n        # Buscar y reemplazar la opci√≥n 6 actual (que debe ser la de salir)\n        if 'opcion == \"6\"' in funcion_completa:\n            print(\"‚ö†Ô∏è  Opci√≥n 6 actualmente configurada para salir, cambiando a META-VECTA...\")\n            \n            # C√≥digo para la opci√≥n 6 (META-VECTA)\n            codigo_opcion6 = '''    elif opcion == \"6\":\n        # Sistema META-VECTA\n        print(\"\\\\n\" + \"=\"*70)\n        print(\"üöÄ SISTEMA META-VECTA - Especificaci√≥n 1.0\")\n        print(\"=\"*70)\n        \n        try:\n            from core.meta_vecta import VECTASystem, test_vecta_system\n            \n            print(\"\\\\nOpciones META-VECTA:\")\n            print(\"  1. Ejecutar prueba completa\")\n            print(\"  2. Procesar intenci√≥n personalizada\")\n            print(\"  3. Ver estado del sistema META-VECTA\")\n            print(\"  4. Volver al men√∫ principal\")\n            \n            sub_opcion = input(\"\\\\nSeleccione opci√≥n (1-4): \").strip()\n            \n            if sub_opcion == \"1\":\n                print(\"\\\\nüß™ Ejecutando prueba META-VECTA...\")\n                test_vecta_system()\n                \n            elif sub_opcion == \"2\":\n                print(\"\\\\n\" + \"-\"*50)\n                print(\"PROCESADOR DE INTENCIONES META-VECTA\")\n                print(\"-\"*50)\n                \n                texto = input(\"Intenci√≥n: \").strip()\n                if not texto:\n                    print(\"‚ùå Intenci√≥n vac√≠a\")\n                else:\n                    vecta = VECTASystem()\n                    resultado = vecta.process_intention(\n                        texto,\n                        context={\"domain\": \"LONG_TERM_PLANNING\"},\n                        auth_key=\"RAFAEL_PORLEY_VECTA\"\n                    )\n                    \n                    if resultado.get(\"success\"):\n                        print(f\"\\\\n‚úÖ Decisi√≥n: {resultado['decision']['action']}\")\n                        print(f\"üìä Probabilidad: {resultado['decision']['probability']:.1%}\")\n                        print(f\"üîç Interpretaci√≥n: {resultado['field_interpretation']}\")\n                    else:\n                        print(f\"\\\\n‚ùå Error: {resultado.get('error')}\")\n                        \n            elif sub_opcion == \"3\":\n                vecta = VECTASystem()\n                estado = vecta.get_system_status()\n                \n                print(f\"\\\\nüìä ESTADO META-VECTA:\")\n                print(f\"  ‚Ä¢ Versi√≥n: {estado['meta']['version']}\")\n                print(f\"  ‚Ä¢ Creador: {estado['meta']['creator']}\")\n                print(f\"  ‚Ä¢ Principios: {estado['meta']['principles_count']}\")\n                print(f\"  ‚Ä¢ S√≠mbolos: {estado['language']['base_symbols']} base\")\n                print(f\"  ‚Ä¢ Ciclos: {estado['runtime']['cycles_executed']}\")\n                print(f\"  ‚Ä¢ Dominios: {', '.join(estado['safety']['authorized_domains'])}\")\n                \n            else:\n                print(\"Volviendo al men√∫ principal...\")\n                \n        except ImportError as e:\n            print(f\"‚ùå Error: {e}\")\n            print(\"  Aseg√∫rate de que core/meta_vecta.py existe\")\n        except Exception as e:\n            print(f\"‚ùå Error inesperado: {e}\")\n        \n        input(\"\\\\nPresione Enter para continuar...\")\n        return True'''\n        \n            # Encontrar y reemplazar el bloque de la opci√≥n 6 act"
    },
    "reparar_vecta.py": {
      "tipo": "archivo",
      "extension": ".py",
      "tamano_bytes": 10642,
      "tamano_humano": "10.39 KB",
      "ruta": "reparar_vecta.py",
      "contenido_preview": "\"\"\"\nVECTA 12D - SISTEMA DE REPARACI√ìN AUTOM√ÅTICA\nScript √∫nico para diagnosticar y reparar todo el sistema\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport shutil\n\nprint(\"\\n\" + \"=\"*70)\nprint(\"üöÄ VECTA 12D - REPARACI√ìN AUTOM√ÅTICA\")\nprint(\"=\"*70)\nprint(f\"Hora de inicio: {time.strftime('%H:%M:%S')}\")\nprint(f\"Directorio: {os.getcwd()}\")\nprint(\"=\"*70)\n\n# ======================= PASO 1: DIAGN√ìSTICO =======================\nprint(\"\\n[1/5] üîç EJECUTANDO DIAGN√ìSTICO COMPLETO...\")\n\nproblemas = []\nadvertencias = []\n\n# 1. Verificar directorios\nprint(\"\\n  üìÅ Verificando estructura...\")\nif os.path.exists(\"core\"):\n    print(\"    ‚úì Directorio 'core' encontrado\")\nelse:\n    print(\"    ‚úó Directorio 'core' NO encontrado\")\n    problemas.append(\"Falta directorio 'core'\")\n\nif os.path.exists(\"dimensiones\"):\n    print(\"    ‚úì Directorio 'dimensiones' encontrado\")\nelse:\n    print(\"    ‚úó Directorio 'dimensiones' NO encontrado\")\n    problemas.append(\"Falta directorio 'dimensiones'\")\n\n# 2. Verificar archivos cr√≠ticos\nprint(\"\\n  üìÑ Verificando archivos cr√≠ticos...\")\narchivos_criticos = [\n    (\"core/vecta_12d_core.py\", \"Archivo principal del n√∫cleo\"),\n    (\"core/__init__.py\", \"Paquete del n√∫cleo\"),\n    (\"dimensiones/vector_12d.py\", \"Sistema vectorial 12D\"),\n    (\"vecta_launcher.py\", \"Lanzador principal\")\n]\n\nfor archivo, descripcion in archivos_criticos:\n    if os.path.exists(archivo):\n        tama√±o = os.path.getsize(archivo)\n        if tama√±o > 100:\n            print(f\"    ‚úì {archivo} ({tama√±o} bytes)\")\n        else:\n            print(f\"    ‚ö†Ô∏è  {archivo} muy peque√±o ({tama√±o} bytes)\")\n            advertencias.append(f\"{archivo} tiene solo {tama√±o} bytes\")\n    else:\n        print(f\"    ‚úó {archivo} NO encontrado\")\n        problemas.append(f\"Falta {descripcion}\")\n\n# 3. Contar dimensiones\nprint(\"\\n  üìä Contando dimensiones...\")\ndimensiones_encontradas = 0\nfor i in range(1, 13):\n    archivo = f\"dimensiones/dimension_{i}.py\"\n    if os.path.exists(archivo):\n        dimensiones_encontradas += 1\n\nprint(f\"    ‚úì Archivos de dimensiones: {dimensiones_encontradas}/12\")\n\nif dimensiones_encontradas < 12:\n    advertencias.append(f\"Solo {dimensiones_encontradas} de 12 dimensiones encontradas\")\n\n# 4. Verificar Python\nprint(\"\\n  üêç Verificando Python...\")\ntry:\n    version = sys.version.split()[0]\n    print(f\"    ‚úì Python {version} detectado\")\nexcept:\n    print(\"    ‚ö†Ô∏è  No se pudo verificar Python\")\n\n# Mostrar resumen de diagn√≥stico\nprint(\"\\n\" + \"-\"*70)\nprint(\"üìã RESUMEN DE DIAGN√ìSTICO\")\nprint(\"-\"*70)\n\nif problemas:\n    print(\"üö® PROBLEMAS CR√çTICOS:\")\n    for p in problemas:\n        print(f\"  ‚úó {p}\")\nelse:\n    print(\"‚úÖ No hay problemas cr√≠ticos\")\n\nif advertencias:\n    print(\"\\n‚ö†Ô∏è  ADVERTENCIAS:\")\n    for a in advertencias:\n        print(f\"  ! {a}\")\nelse:\n    print(\"‚úÖ No hay advertencias\")\n\nprint(\"-\"*70)\n\n# ======================= PASO 2: REPARAR VECTOR_12D.PY =======================\nprint(\"\\n[2/5] üõ†Ô∏è  REPARANDO vector_12d.py...\")\n\n# Primero hacer backup si existe\narchivo_vector = \"dimensiones/vector_12d.py\"\nif os.path.exists(archivo_vector):\n    try:\n        shutil.copy2(archivo_vector, \"dimensiones/vector_12d.py.backup\")\n        print(\"  ‚úì Backup creado: vector_12d.py.backup\")\n    except:\n        print(\"  ‚ö†Ô∏è  No se pudo hacer backup\")\n\n# Crear nuevo vector_12d.py corregido\ncodigo_corregido = '''\"\"\"\nSISTEMA VECTORIAL 12D - VERSI√ìN CORREGIDA\nSistema unificado de 12 dimensiones vectoriales\n\"\"\"\n\nimport sys\nimport os\nimport importlib\n\nclass Vector12D:\n    def __init__(self, dimensiones):\n        self.dimensiones = dimensiones\n    \n    def magnitud(self):\n        import math\n        suma = sum(d * d for d in self.dimensiones)\n        return math.sqrt(suma) if suma > 0 else 0.0\n    \n    def __str__(self):\n        dims = \", \".join([f\"{d:.4f}\" for d in self.dimensiones])\n        return f\"Vector12D(mag={self.magnitud():.4f}, dims=[{dims}])\"\n\nclass SistemaVectorial12D:\n    def __init__(self):\n        self.dimensiones = []\n        self._cargar_dimensiones()\n    \n    def _cargar_dimensiones(self):\n        \"\"\"Carga las 12 dimensiones\"\"\"\n        dimensiones_cargadas = 0\n        \n        for i in range(1, 13):\n            try:\n                # Verificar si el archivo existe\n                archivo = f\"dimensiones/dimension_{i}.py\"\n                if not os.path.exists(archivo):\n                    continue\n                \n                # Importar el m√≥dulo\n                modulo_nombre = f\"dimensiones.dimension_{i}\"\n                modulo = importlib.import_module(modulo_nombre)\n                \n                # Buscar clases en el m√≥dulo\n                for nombre in dir(modulo):\n                    obj = getattr(modulo, nombre)\n                    if isinstance(obj, type):\n                        # Crear instancia\n                        instancia = obj()\n                        self.dimensiones.append(instancia)\n                        dimensiones_cargadas += 1\n                        break\n                        \n            except Exception:\n                continue\n        "
    },
    "VECTA_12D_Automatico.zip": {
      "tipo": "archivo",
      "extension": ".zip",
      "tamano_bytes": 10849,
      "tamano_humano": "10.59 KB",
      "ruta": "VECTA_12D_Automatico.zip",
      "contenido_preview": null
    },
    "vecta_12d_launcher.py": {
      "tipo": "archivo",
      "extension": ".py",
      "tamano_bytes": 4510,
      "tamano_humano": "4.40 KB",
      "ruta": "vecta_12d_launcher.py",
      "contenido_preview": "#!/usr/bin/env python3\n\"\"\"\nVECTA 12D - LANZADOR PRINCIPAL\nSistema de 12 Dimensiones Vectoriales\nVersi√≥n: 2.0.0\n\"\"\"\nimport sys\nimport os\nfrom pathlib import Path\n\ndef main():\n    print(\"\\n\" + \"=\"*60)\n    print(\"üöÄ VECTA 12D - SISTEMA DE 12 DIMENSIONES\")\n    print(\"=\"*60)\n    print(\"Versi√≥n: 2.0.0\")\n    print(\"Modo: Sistema Vectorial Autoprogramable\")\n    print(\"=\"*60)\n    \n    # Asegurarnos de que estamos en el directorio correcto\n    base_dir = Path(__file__).parent\n    os.chdir(base_dir)\n    \n    # A√±adir directorios al path\n    sys.path.insert(0, str(base_dir))\n    if (base_dir / \"dimensiones\").exists():\n        sys.path.insert(0, str(base_dir / \"dimensiones\"))\n    if (base_dir / \"core\").exists():\n        sys.path.insert(0, str(base_dir / \"core\"))\n    \n    try:\n        # Intentar cargar el n√∫cleo de VECTA\n        print(\"\\nüì¶ Cargando sistema VECTA 12D...\")\n        \n        # Primero verificar si existen los archivos necesarios\n        if not (base_dir / \"core\" / \"vecta_12d_core.py\").exists():\n            print(\"‚ùå Error: No se encontr√≥ el n√∫cleo de VECTA\")\n            print(\"   Aseg√∫rate de que 'core/vecta_12d_core.py' existe\")\n            input(\"\\nPresiona Enter para salir...\")\n            return\n        \n        # Importar el n√∫cleo\n        from core.vecta_12d_core import VECTA_12D_Core\n        \n        print(\"‚úÖ Sistema cargado exitosamente\")\n        print(\"‚úÖ 12 dimensiones vectoriales activas\")\n        \n        # Crear instancia\n        vecta = VECTA_12D_Core()\n        \n        # Verificar modo de ejecuci√≥n\n        if len(sys.argv) > 1:\n            if sys.argv[1] == \"--gui\":\n                print(\"\\nüé® Iniciando interfaz gr√°fica...\")\n                vecta.start_gui()\n            elif sys.argv[1] == \"--help\" or sys.argv[1] == \"-h\":\n                mostrar_ayuda()\n            else:\n                print(f\"\\n‚ö†Ô∏è  Opci√≥n desconocida: {sys.argv[1]}\")\n                mostrar_ayuda()\n        else:\n            # Modo por defecto: interfaz de texto\n            print(\"\\nüíª Iniciando en modo consola...\")\n            print(\"   Escribe 'salir' para terminar\")\n            print(\"   Escribe 'estado' para ver informaci√≥n del sistema\")\n            print(\"   Escribe 'ayuda' para ver comandos disponibles\")\n            print(\"-\" * 40)\n            vecta.start_text_interface()\n            \n    except ImportError as e:\n        print(f\"‚ùå Error importando m√≥dulos: {e}\")\n        print(\"\\nüìã Soluci√≥n:\")\n        print(\"1. Ejecuta primero: python vecta_corregido.py\")\n        print(\"2. O verifica que los directorios 'core/' y 'dimensiones/' existen\")\n        \n        # Mostrar estructura actual\n        print(\"\\nüìÅ Estructura actual:\")\n        for item in base_dir.iterdir():\n            if item.is_dir():\n                print(f\"  üìÅ {item.name}/\")\n            else:\n                print(f\"  üìÑ {item.name}\")\n        \n        input(\"\\nPresiona Enter para salir...\")\n        \n    except Exception as e:\n        print(f\"‚ùå Error inesperado: {e}\")\n        import traceback\n        traceback.print_exc()\n        input(\"\\nPresiona Enter para salir...\")\n\ndef mostrar_ayuda():\n    \"\"\"Muestra la ayuda del sistema\"\"\"\n    print(\"\\nüìñ AYUDA VECTA 12D:\")\n    print(\"=\"*40)\n    print(\"Uso: python vecta_launcher.py [OPCI√ìN]\")\n    print(\"\\nOpciones:\")\n    print(\"  --gui       Inicia interfaz gr√°fica\")\n    print(\"  --help      Muestra esta ayuda\")\n    print(\"  --version   Muestra la versi√≥n\")\n    print(\"\\nSin opciones: Inicia en modo consola\")\n    print(\"\\nComandos en modo consola:\")\n    print(\"  salir       Termina el programa\")\n    print(\"  estado      Muestra informaci√≥n del sistema\")\n    print(\"  ayuda       Muestra comandos disponibles\")\n    print(\"=\"*40)\n\ndef mostrar_version():\n    \"\"\"Muestra la versi√≥n del sistema\"\"\"\n    print(\"\\nüìä VERSI√ìN VECTA 12D:\")\n    print(\"=\"*40)\n    print(\"Sistema: VECTA 12D\")\n    print(\"Versi√≥n: 2.0.0\")\n    print(\"Estado: Sistema de 12 Dimensiones Vectoriales\")\n    print(\"Autor: Sistema Autoprogramable VECTA\")\n    print(\"=\"*40)\n\nif __name__ == \"__main__\":\n    # Verificar si se solicita ayuda o versi√≥n\n    if len(sys.argv) > 1:\n        if sys.argv[1] == \"--version\" or sys.argv[1] == \"-v\":\n            mostrar_version()\n            sys.exit(0)\n        elif sys.argv[1] == \"--help\" or sys.argv[1] == \"-h\":\n            mostrar_ayuda()\n            sys.exit(0)\n    \n    main()"
    },
    "vecta_auto_build.py": {
      "tipo": "archivo",
      "extension": ".py",
      "tamano_bytes": 46842,
      "tamano_humano": "45.74 KB",
      "ruta": "vecta_auto_build.py",
      "contenido_preview": "#!/usr/bin/env python3\n\"\"\"\nVECTA 12D - SISTEMA AUTOM√ÅTICO COMPLETO\n========================================\nEste script √∫nico realiza todas las tareas autom√°ticamente:\n1. Verifica entorno y dependencias\n2. Crea sistema de 12 dimensiones\n3. Genera paquete .pkg\n4. Crea ZIP de distribuci√≥n\n5. Ejecuta autodiagn√≥stico\n\nINSTRUCCIONES:\n1. Guarda este archivo en: C:\\Users\\Rafael\\Desktop\\VECTA 12D Automatico\\\n2. Ejecuta: python vecta_auto_build.py\n3. Si hay errores, COPIA Y PEGA TODO EL OUTPUT en el chat\n\"\"\"\n\nimport os\nimport sys\nimport json\nimport zipfile\nimport shutil\nimport time\nimport subprocess\nimport tempfile\nimport importlib.util\nfrom pathlib import Path\nfrom datetime import datetime\nfrom typing import Dict, List, Any, Tuple\nimport traceback\n\n# ============================================================================\n# CONFIGURACI√ìN Y CONSTANTES\n# ============================================================================\nclass Config:\n    VERSION = \"2.0.0\"\n    BUILD_DATE = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    PROJECT_DIR = Path.cwd()\n    DIMENSIONES_DIR = PROJECT_DIR / \"dimensiones\"\n    CORE_DIR = PROJECT_DIR / \"core\"\n    PAQUETE_PKG = \"paquete_vecta.pkg\"\n    ZIP_FINAL = \"VECTA_12D_Automatico.zip\"\n    \n    ARCHIVOS_REQUERIDOS = [\n        \"INSTALAR.bat\",\n        \"vecta_self_install.py\", \n        \"vecta_12d_launcher.py\",\n        \"paquete_vecta.pkg\"\n    ]\n\n# ============================================================================\n# SISTEMA DE LOGGING Y AUTODIAGN√ìSTICO\n# ============================================================================\nclass AutoDiagnostico:\n    def __init__(self):\n        self.errores = []\n        self.advertencias = []\n        self.exitos = []\n        self.start_time = time.time()\n    \n    def registrar_error(self, modulo: str, error: str, detalles: str = \"\"):\n        registro = {\n            \"modulo\": modulo,\n            \"error\": str(error),\n            \"detalles\": detalles,\n            \"timestamp\": time.time()\n        }\n        self.errores.append(registro)\n        print(f\"‚ùå ERROR en {modulo}: {error}\")\n        if detalles:\n            print(f\"   Detalles: {detalles}\")\n    \n    def registrar_exito(self, modulo: str, mensaje: str):\n        registro = {\n            \"modulo\": modulo,\n            \"mensaje\": mensaje,\n            \"timestamp\": time.time()\n        }\n        self.exitos.append(registro)\n        print(f\"‚úÖ {modulo}: {mensaje}\")\n    \n    def registrar_advertencia(self, modulo: str, mensaje: str):\n        registro = {\n            \"modulo\": modulo,\n            \"mensaje\": mensaje,\n            \"timestamp\": time.time()\n        }\n        self.advertencias.append(registro)\n        print(f\"‚ö†Ô∏è  {modulo}: {mensaje}\")\n    \n    def generar_reporte(self) -> str:\n        tiempo_total = time.time() - self.start_time\n        \n        reporte = []\n        reporte.append(\"=\" * 80)\n        reporte.append(\"üìã INFORME DE AUTODIAGN√ìSTICO VECTA 12D\")\n        reporte.append(\"=\" * 80)\n        reporte.append(f\"Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n        reporte.append(f\"Versi√≥n: {Config.VERSION}\")\n        reporte.append(f\"Tiempo total: {tiempo_total:.2f} segundos\")\n        reporte.append(\"\")\n        \n        reporte.append(\"‚úÖ √âXITOS:\")\n        reporte.append(\"-\" * 40)\n        if self.exitos:\n            for exito in self.exitos:\n                reporte.append(f\"‚Ä¢ {exito['modulo']}: {exito['mensaje']}\")\n        else:\n            reporte.append(\"Ninguno\")\n        \n        reporte.append(\"\")\n        reporte.append(\"‚ö†Ô∏è  ADVERTENCIAS:\")\n        reporte.append(\"-\" * 40)\n        if self.advertencias:\n            for adv in self.advertencias:\n                reporte.append(f\"‚Ä¢ {adv['modulo']}: {adv['mensaje']}\")\n        else:\n            reporte.append(\"Ninguna\")\n        \n        reporte.append(\"\")\n        reporte.append(\"‚ùå ERRORES:\")\n        reporte.append(\"-\" * 40)\n        if self.errores:\n            for error in self.errores:\n                reporte.append(f\"‚Ä¢ {error['modulo']}: {error['error']}\")\n                if error['detalles']:\n                    reporte.append(f\"  ‚Üí {error['detalles']}\")\n        else:\n            reporte.append(\"Ninguno\")\n        \n        reporte.append(\"\")\n        reporte.append(\"=\" * 80)\n        reporte.append(\"üìä RESUMEN:\")\n        reporte.append(f\"√âxitos: {len(self.exitos)}\")\n        reporte.append(f\"Advertencias: {len(self.advertencias)}\")\n        reporte.append(f\"Errores: {len(self.errores)}\")\n        reporte.append(f\"Estado: {'‚úÖ COMPLETADO' if len(self.errores) == 0 else '‚ö†Ô∏è  CON ERRORES'}\")\n        reporte.append(\"=\" * 80)\n        \n        return \"\\n\".join(reporte)\n    \n    def guardar_reporte(self, archivo: str = \"diagnostico_vecta.txt\"):\n        contenido = self.generar_reporte()\n        with open(archivo, 'w', encoding='utf-8') as f:\n            f.write(contenido)\n        return archivo\n\n# ============================================================================\n# PASO 1: VERIFICACI√ìN DEL ENTORNO\n# =============================="
    },
    "vecta_corregido.py": {
      "tipo": "archivo",
      "extension": ".py",
      "tamano_bytes": 21215,
      "tamano_humano": "20.72 KB",
      "ruta": "vecta_corregido.py",
      "contenido_preview": "import os\nimport sys\nimport json\nimport zipfile\nimport shutil\nimport time\nimport subprocess\nimport tempfile\nimport importlib.util\nfrom pathlib import Path\nfrom datetime import datetime\nimport traceback\n\n# ============================================================================\n# CONFIGURACION\n# ============================================================================\nclass Config:\n    VERSION = \"2.0.0\"\n    BUILD_DATE = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    PROJECT_DIR = Path.cwd()\n    DIMENSIONES_DIR = PROJECT_DIR / \"dimensiones\"\n    CORE_DIR = PROJECT_DIR / \"core\"\n    PAQUETE_PKG = PROJECT_DIR / \"paquete_vecta.pkg\"  # CORREGIDO: Ahora es Path\n    ZIP_FINAL = PROJECT_DIR / \"VECTA_12D_Automatico.zip\"  # CORREGIDO: Ahora es Path\n\n# ============================================================================\n# SISTEMA DE DIAGNOSTICO\n# ============================================================================\nclass AutoDiagnostico:\n    def __init__(self):\n        self.errores = []\n        self.exitos = []\n        self.advertencias = []\n    \n    def error(self, modulo, mensaje):\n        self.errores.append(f\"{modulo}: {mensaje}\")\n        print(f\"[ERROR] {modulo}: {mensaje}\")\n    \n    def exito(self, modulo, mensaje):\n        self.exitos.append(f\"{modulo}: {mensaje}\")\n        print(f\"[OK] {modulo}: {mensaje}\")\n    \n    def advertencia(self, modulo, mensaje):\n        self.advertencias.append(f\"{modulo}: {mensaje}\")\n        print(f\"[ADVERTENCIA] {modulo}: {mensaje}\")\n    \n    def reporte(self):\n        print(\"\\n\" + \"=\"*60)\n        print(\"REPORTE DE DIAGNOSTICO\")\n        print(\"=\"*60)\n        print(f\"Exitos: {len(self.exitos)}\")\n        print(f\"Advertencias: {len(self.advertencias)}\")\n        print(f\"Errores: {len(self.errores)}\")\n        \n        if self.errores:\n            print(\"\\nERRORES:\")\n            for e in self.errores:\n                print(f\"  ‚Ä¢ {e}\")\n        \n        return len(self.errores) == 0\n\n# ============================================================================\n# PASO 1: VERIFICAR ENTORNO\n# ============================================================================\ndef verificar_entorno(diag):\n    print(\"\\n\" + \"=\"*60)\n    print(\"PASO 1: VERIFICANDO ENTORNO\")\n    print(\"=\"*60)\n    \n    # Verificar Python\n    try:\n        version = sys.version_info\n        if version.major == 3 and version.minor >= 7:\n            diag.exito(\"Python\", f\"Version {version.major}.{version.minor}.{version.micro} OK\")\n        else:\n            diag.error(\"Python\", f\"Version {version.major}.{version.minor} detectada. Se requiere 3.7+\")\n            return False\n    except:\n        diag.error(\"Python\", \"No se pudo verificar version\")\n        return False\n    \n    # Verificar directorios\n    try:\n        Config.DIMENSIONES_DIR.mkdir(exist_ok=True)\n        Config.CORE_DIR.mkdir(exist_ok=True)\n        diag.exito(\"Directorios\", \"Estructura creada\")\n    except Exception as e:\n        diag.error(\"Directorios\", f\"Error: {e}\")\n        return False\n    \n    return True\n\n# ============================================================================\n# PASO 2: CREAR DIMENSIONES\n# ============================================================================\ndef crear_dimensiones(diag):\n    print(\"\\n\" + \"=\"*60)\n    print(\"PASO 2: CREANDO DIMENSIONES 12D\")\n    print(\"=\"*60)\n    \n    dimensiones = {\n        1: (\"Tiempo-Entropia\", '''\nclass DimensionTiempoEntropia:\n    def __init__(self):\n        self.nombre = \"Tiempo-Entropia\"\n        self.magnitud = 0.0\n    \n    def procesar(self, datos):\n        import time\n        return {\"dimension\": self.nombre, \"magnitud\": 0.5, \"timestamp\": time.time()}'''),\n        \n        2: (\"Espacio-Volumen\", '''\nclass DimensionEspacioVolumen:\n    def __init__(self):\n        self.nombre = \"Espacio-Volumen\"\n        self.magnitud = 0.0\n    \n    def procesar(self, datos):\n        return {\"dimension\": self.nombre, \"magnitud\": 0.6}'''),\n        \n        3: (\"Energia-Potencial\", '''\nclass DimensionEnergiaPotencial:\n    def __init__(self):\n        self.nombre = \"Energia-Potencial\"\n        self.magnitud = 0.0\n    \n    def procesar(self, datos):\n        return {\"dimension\": self.nombre, \"magnitud\": 0.3}'''),\n        \n        4: (\"Informacion-Entropia\", '''\nclass DimensionInformacionEntropia:\n    def __init__(self):\n        self.nombre = \"Informacion-Entropia\"\n        self.magnitud = 0.0\n    \n    def procesar(self, datos):\n        return {\"dimension\": self.nombre, \"magnitud\": 0.4}'''),\n        \n        5: (\"Conciencia-Atencion\", '''\nclass DimensionConcienciaAtencion:\n    def __init__(self):\n        self.nombre = \"Conciencia-Atencion\"\n        self.magnitud = 0.0\n    \n    def procesar(self, datos):\n        return {\"dimension\": self.nombre, \"magnitud\": 0.2}'''),\n        \n        6: (\"Memoria-Persistencia\", '''\nclass DimensionMemoriaPersistencia:\n    def __init__(self):\n        self.nombre = \"Memoria-Persistencia\"\n        self.magnitud = 0.0\n    \n    def procesar(self, datos):\n        return {\"dimen"
    },
    "vecta_launcher.py": {
      "tipo": "archivo",
      "extension": ".py",
      "tamano_bytes": 13581,
      "tamano_humano": "13.26 KB",
      "ruta": "vecta_launcher.py",
      "contenido_preview": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nVECTA 12D LAUNCHER - Sistema Autoprogramable\n============================================\nLanzador principal del sistema de 12 dimensiones vectoriales.\n\"\"\"\n\nimport sys\nimport os\nimport traceback\nfrom datetime import datetime\n\n# Configurar path para importaciones\nBASE_DIR = os.path.dirname(os.path.abspath(__file__))\nsys.path.insert(0, BASE_DIR)\n\ndef mostrar_banner():\n    \"\"\"Muestra el banner de inicio del sistema.\"\"\"\n    print(\"\\n\" + \"=\" * 70)\n    print(\"‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\")\n    print(\"‚ïë                   VECTA 12D - SISTEMA AUTOPROGRAMABLE        ‚ïë\")\n    print(\"‚ïë                   12 Dimensiones Vectoriales                 ‚ïë\")\n    print(\"‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\")\n    print(\"=\" * 70)\n    print(f\"Inicio: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n    print(f\"Directorio: {BASE_DIR}\")\n    print(\"=\" * 70)\n\ndef inicializar_sistema():\n    \"\"\"Inicializa y verifica todos los componentes del sistema.\"\"\"\n    print(\"\\n[1/3] üöÄ INICIALIZANDO SISTEMA VECTA 12D...\")\n    \n    # Verificar estructura de directorios\n    directorios_necesarios = ['core', 'dimensiones']\n    for dir_name in directorios_necesarios:\n        if not os.path.exists(dir_name):\n            print(f\"  ‚ùå ERROR: Directorio '{dir_name}' no encontrado\")\n            return None\n        print(f\"  ‚úì Directorio '{dir_name}' encontrado\")\n    \n    # Verificar archivos cr√≠ticos\n    archivos_criticos = [\n        'core/vecta_12d_core.py',\n        'dimensiones/vector_12d.py'\n    ]\n    \n    for archivo in archivos_criticos:\n        if not os.path.exists(archivo):\n            print(f\"  ‚ùå ERROR: Archivo '{archivo}' no encontrado\")\n            return None\n        print(f\"  ‚úì Archivo '{archivo}' encontrado\")\n    \n    return True\n\ndef cargar_nucleo():\n    \"\"\"Carga el n√∫cleo principal de VECTA 12D.\"\"\"\n    print(\"\\n[2/3] ‚öôÔ∏è CARGANDO N√öCLEO VECTA 12D...\")\n    \n    try:\n        # Importar n√∫cleo principal\n        from core.vecta_12d_core import VECTA_12D_Core\n        \n        # Crear instancia\n        vecta = VECTA_12D_Core()\n        \n        # Verificar dimensiones\n        if hasattr(vecta, 'dimensiones'):\n            num_dimensiones = len(vecta.dimensiones)\n            print(f\"  ‚úì N√∫cleo cargado: {num_dimensiones} dimensiones activas\")\n        else:\n            print(f\"  ‚úì N√∫cleo cargado (atributo 'dimensiones' no disponible)\")\n        \n        return vecta\n        \n    except ImportError as e:\n        print(f\"  ‚ùå ERROR de importaci√≥n: {e}\")\n        print(f\"  Traceback: {traceback.format_exc()}\")\n        return None\n    except Exception as e:\n        print(f\"  ‚ùå ERROR inesperado: {e}\")\n        return None\n\ndef cargar_sistema_vectorial():\n    \"\"\"Carga el sistema vectorial 12D.\"\"\"\n    print(\"\\n[3/3] üîÑ CARGANDO SISTEMA VECTORIAL 12D...\")\n    \n    try:\n        from dimensiones.vector_12d import SistemaVectorial12D\n        \n        sistema = SistemaVectorial12D()\n        \n        # Intentar obtener n√∫mero de dimensiones\n        try:\n            num_dim = sistema.obtener_numero_dimensiones()\n            print(f\"  ‚úì Sistema vectorial: {num_dim} dimensiones cargadas\")\n        except:\n            # Si falla, intentar m√©todo alternativo\n            if hasattr(sistema, 'dimensiones'):\n                print(f\"  ‚úì Sistema vectorial: {len(sistema.dimensiones)} dimensiones cargadas\")\n            else:\n                print(f\"  ‚úì Sistema vectorial cargado (m√©todo de conteo no disponible)\")\n        \n        return sistema\n        \n    except Exception as e:\n        print(f\"  ‚ö†Ô∏è Sistema vectorial no disponible: {e}\")\n        return None\n\ndef mostrar_menu_principal():\n    \"\"\"Muestra el men√∫ principal de opciones.\"\"\"\n    print(\"\\n\" + \"‚ïê\" * 70)\n    print(\"MEN√ö PRINCIPAL - VECTA 12D\")\n    print(\"‚ïê\" * 70)\n    print(\"1. Procesar texto/comando\")\n    print(\"2. Ver estado del sistema\")\n    print(\"3. Probar dimensiones individuales\")\n    print(\"4. Ejecutar autodiagn√≥stico\")\n    print(\"5. Generar vector 12D aleatorio\")\n    print(\"6. Sistema META-VECTA (Nuevo)\")\n    print(\"7. Salir del sistema\")\n    print(\"‚ïê\" * 70)\n\ndef procesar_opcion(opcion, vecta, sistema_vectorial):\n    \"\"\"Procesa la opci√≥n seleccionada del men√∫.\"\"\"\n    \n    if opcion == \"1\":\n        # Procesar entrada de texto\n        entrada = input(\"\\nüìù Ingrese texto/comando a procesar: \").strip()\n        if entrada:\n            print(f\"\\nüîÑ Procesando: '{entrada}'\")\n            try:\n                resultado = vecta.procesar(entrada)\n                print(f\"\\n‚úÖ RESULTADO:\")\n                print(f\"   Entrada: {entrada}\")\n                print(f\"   Salida: {resultado}\")\n                \n                # Si hay sistema vectorial, procesar tambi√©n all√≠\n                if sistema_vectorial:\n                    evento = {\"texto\": entrada, \"timestamp\": datetime.now().isoformat()}\n                    vector_resultado = sistema_vectorial.procesar_evento(evento)\n                    print(f\"   Vector 12D generado: S√≠"
    },
    "vecta_launcher.py.backup_20251225_185345": {
      "tipo": "archivo",
      "extension": ".backup_20251225_185345",
      "tamano_bytes": 13537,
      "tamano_humano": "13.22 KB",
      "ruta": "vecta_launcher.py.backup_20251225_185345",
      "contenido_preview": null
    },
    "vecta_launcher.pydir": {
      "tipo": "archivo",
      "extension": ".pydir",
      "tamano_bytes": 31,
      "tamano_humano": "0.03 KB",
      "ruta": "vecta_launcher.pydir",
      "contenido_preview": null
    },
    "vecta_self_install.py": {
      "tipo": "archivo",
      "extension": ".py",
      "tamano_bytes": 9983,
      "tamano_humano": "9.75 KB",
      "ruta": "vecta_self_install.py",
      "contenido_preview": "#!/usr/bin/env python3\n\"\"\"\nVECTA 12D - INSTALADOR AUTO-CONTENIDO\nDescomprime e instala todo autom√°ticamente\n\"\"\"\nimport os\nimport sys\nimport zipfile\nimport json\nimport shutil\nimport subprocess\nimport tempfile\nfrom pathlib import Path\n\nclass VECTA_AutoInstaller:\n    \"\"\"Instalador autom√°tico que funciona sin dependencias externas\"\"\"\n    \n    def __init__(self):\n        self.install_dir = Path.home() / \"VECTA_12D\"\n        self.backup_dir = Path.home() / \"VECTA_12D_Backup\"\n        self.package_file = \"paquete_vecta.pkg\"\n        \n    def banner(self):\n        \"\"\"Muestra banner de instalaci√≥n\"\"\"\n        print(\"\\n\" + \"=\"*60)\n        print(\"   üåÄ VECTA 12D - INSTALACI√ìN AUTOM√ÅTICA\")\n        print(\"   Sistema Autoprogramable de 12 Dimensiones\")\n        print(\"=\"*60)\n        \n    def check_python(self):\n        \"\"\"Verifica versi√≥n de Python\"\"\"\n        version = sys.version_info\n        print(f\"‚úÖ Python {version.major}.{version.minor}.{version.micro}\")\n        \n        if version.major < 3 or (version.major == 3 and version.minor < 8):\n            print(\"‚ùå Se requiere Python 3.8 o superior\")\n            return False\n        return True\n    \n    def backup_existing(self):\n        \"\"\"Hace backup de instalaci√≥n previa\"\"\"\n        if self.install_dir.exists():\n            print(f\"üì¶ Haciendo backup de instalaci√≥n existente...\")\n            if self.backup_dir.exists():\n                shutil.rmtree(self.backup_dir)\n            shutil.copytree(self.install_dir, self.backup_dir)\n            print(f\"‚úÖ Backup guardado en: {self.backup_dir}\")\n    \n    def extract_package(self):\n        \"\"\"Extrae el paquete completo\"\"\"\n        print(f\"üì¶ Extrayendo paquete VECTA 12D...\")\n        \n        if not os.path.exists(self.package_file):\n            print(f\"‚ùå No se encontr√≥ {self.package_file}\")\n            return False\n        \n        # Crear directorio de instalaci√≥n\n        self.install_dir.mkdir(parents=True, exist_ok=True)\n        \n        # Extraer contenido\n        with zipfile.ZipFile(self.package_file, 'r') as zip_ref:\n            zip_ref.extractall(self.install_dir)\n        \n        print(f\"‚úÖ Paquete extra√≠do en: {self.install_dir}\")\n        return True\n    \n    def install_dependencies(self):\n        \"\"\"Instala dependencias autom√°ticamente\"\"\"\n        print(f\"üì¶ Instalando dependencias...\")\n        \n        requirements = [\n            \"numpy\",\n            \"cryptography\",\n            \"psutil\",\n            \"requests\"\n        ]\n        \n        for package in requirements:\n            try:\n                subprocess.check_call([\n                    sys.executable, \"-m\", \"pip\", \"install\", \n                    \"--quiet\", \"--no-warn-script-location\", package\n                ])\n                print(f\"  ‚úÖ {package}\")\n            except:\n                print(f\"  ‚ö†Ô∏è  {package} (puede fallar, VECTA continuar√°)\")\n        \n        print(f\"‚úÖ Dependencias instaladas\")\n    \n    def create_shortcut(self):\n        \"\"\"Crea acceso directo en escritorio\"\"\"\n        print(f\"üîó Creando acceso directo...\")\n        \n        try:\n            import winshell\n            from win32com.client import Dispatch\n            \n            desktop = Path(winshell.desktop())\n            shortcut_path = desktop / \"VECTA 12D.lnk\"\n            \n            target = sys.executable\n            arguments = f'\"{self.install_dir / \"vecta_12d_launcher.py\"}\"'\n            working_dir = str(self.install_dir)\n            \n            shell = Dispatch('WScript.Shell')\n            shortcut = shell.CreateShortCut(str(shortcut_path))\n            shortcut.TargetPath = target\n            shortcut.Arguments = arguments\n            shortcut.WorkingDirectory = working_dir\n            shortcut.IconLocation = sys.executable\n            shortcut.save()\n            \n            print(f\"‚úÖ Acceso directo creado en escritorio\")\n            \n        except ImportError:\n            # Fallback: crear archivo .bat\n            bat_content = f'''@echo off\ncd /d \"{self.install_dir}\"\npython vecta_12d_launcher.py\npause\n'''\n            bat_path = self.install_dir / \"Iniciar_VECTA.bat\"\n            with open(bat_path, 'w') as f:\n                f.write(bat_content)\n            \n            # Copiar a escritorio\n            desktop = Path.home() / \"Desktop\"\n            desktop_bat = desktop / \"Iniciar VECTA.bat\"\n            shutil.copy2(bat_path, desktop_bat)\n            \n            print(f\"‚úÖ Archivo BAT creado en escritorio\")\n        except Exception as e:\n            print(f\"‚ö†Ô∏è  No se pudo crear acceso directo: {e}\")\n    \n    def create_config(self):\n        \"\"\"Crea configuraci√≥n inicial\"\"\"\n        print(f\"‚öôÔ∏è  Creando configuraci√≥n inicial...\")\n        \n        config = {\n            \"version\": \"12D.1.0.0\",\n            \"install_date\": os.path.getctime(__file__),\n            \"dimensions\": 12,\n            \"auto_update\": True,\n            \"security_level\": \"high\",\n            \"paths\": {\n                \"install\": str(self.install_dir),\n                \"data\": str(self.install_dir / \"data\"),\n                \"lo"
    },
    "vecta_simple.py": {
      "tipo": "archivo",
      "extension": ".py",
      "tamano_bytes": 20696,
      "tamano_humano": "20.21 KB",
      "ruta": "vecta_simple.py",
      "contenido_preview": "#!/usr/bin/env python3\n# VECTA 12D - SISTEMA AUTOMATICO COMPLETO\n# ========================================\n\nimport os\nimport sys\nimport json\nimport zipfile\nimport shutil\nimport time\nimport subprocess\nimport tempfile\nimport importlib.util\nfrom pathlib import Path\nfrom datetime import datetime\nimport traceback\n\n# ============================================================================\n# CONFIGURACION\n# ============================================================================\nclass Config:\n    VERSION = \"2.0.0\"\n    BUILD_DATE = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    PROJECT_DIR = Path.cwd()\n    DIMENSIONES_DIR = PROJECT_DIR / \"dimensiones\"\n    CORE_DIR = PROJECT_DIR / \"core\"\n    PAQUETE_PKG = \"paquete_vecta.pkg\"\n    ZIP_FINAL = \"VECTA_12D_Automatico.zip\"\n\n# ============================================================================\n# SISTEMA DE DIAGNOSTICO\n# ============================================================================\nclass AutoDiagnostico:\n    def __init__(self):\n        self.errores = []\n        self.exitos = []\n        self.advertencias = []\n    \n    def error(self, modulo, mensaje):\n        self.errores.append(f\"{modulo}: {mensaje}\")\n        print(f\"[ERROR] {modulo}: {mensaje}\")\n    \n    def exito(self, modulo, mensaje):\n        self.exitos.append(f\"{modulo}: {mensaje}\")\n        print(f\"[OK] {modulo}: {mensaje}\")\n    \n    def advertencia(self, modulo, mensaje):\n        self.advertencias.append(f\"{modulo}: {mensaje}\")\n        print(f\"[ADVERTENCIA] {modulo}: {mensaje}\")\n    \n    def reporte(self):\n        print(\"\\n\" + \"=\"*60)\n        print(\"REPORTE DE DIAGNOSTICO\")\n        print(\"=\"*60)\n        print(f\"Exitos: {len(self.exitos)}\")\n        print(f\"Advertencias: {len(self.advertencias)}\")\n        print(f\"Errores: {len(self.errores)}\")\n        \n        if self.errores:\n            print(\"\\nERRORES:\")\n            for e in self.errores:\n                print(f\"  ‚Ä¢ {e}\")\n        \n        return len(self.errores) == 0\n\n# ============================================================================\n# PASO 1: VERIFICAR ENTORNO\n# ============================================================================\ndef verificar_entorno(diag):\n    print(\"\\n\" + \"=\"*60)\n    print(\"PASO 1: VERIFICANDO ENTORNO\")\n    print(\"=\"*60)\n    \n    # Verificar Python\n    try:\n        version = sys.version_info\n        if version.major == 3 and version.minor >= 7:\n            diag.exito(\"Python\", f\"Version {version.major}.{version.minor}.{version.micro} OK\")\n        else:\n            diag.error(\"Python\", f\"Version {version.major}.{version.minor} detectada. Se requiere 3.7+\")\n            return False\n    except:\n        diag.error(\"Python\", \"No se pudo verificar version\")\n        return False\n    \n    # Verificar directorios\n    try:\n        Config.DIMENSIONES_DIR.mkdir(exist_ok=True)\n        Config.CORE_DIR.mkdir(exist_ok=True)\n        diag.exito(\"Directorios\", \"Estructura creada\")\n    except Exception as e:\n        diag.error(\"Directorios\", f\"Error: {e}\")\n        return False\n    \n    return True\n\n# ============================================================================\n# PASO 2: CREAR DIMENSIONES\n# ============================================================================\ndef crear_dimensiones(diag):\n    print(\"\\n\" + \"=\"*60)\n    print(\"PASO 2: CREANDO DIMENSIONES 12D\")\n    print(\"=\"*60)\n    \n    dimensiones = {\n        1: (\"Tiempo-Entropia\", '''\nclass DimensionTiempoEntropia:\n    def __init__(self):\n        self.nombre = \"Tiempo-Entropia\"\n        self.magnitud = 0.0\n    \n    def procesar(self, datos):\n        import time\n        return {\"dimension\": self.nombre, \"magnitud\": 0.5, \"timestamp\": time.time()}'''),\n        \n        2: (\"Espacio-Volumen\", '''\nclass DimensionEspacioVolumen:\n    def __init__(self):\n        self.nombre = \"Espacio-Volumen\"\n        self.magnitud = 0.0\n    \n    def procesar(self, datos):\n        return {\"dimension\": self.nombre, \"magnitud\": 0.6}'''),\n        \n        3: (\"Energia-Potencial\", '''\nclass DimensionEnergiaPotencial:\n    def __init__(self):\n        self.nombre = \"Energia-Potencial\"\n        self.magnitud = 0.0\n    \n    def procesar(self, datos):\n        return {\"dimension\": self.nombre, \"magnitud\": 0.3}'''),\n        \n        4: (\"Informacion-Entropia\", '''\nclass DimensionInformacionEntropia:\n    def __init__(self):\n        self.nombre = \"Informacion-Entropia\"\n        self.magnitud = 0.0\n    \n    def procesar(self, datos):\n        return {\"dimension\": self.nombre, \"magnitud\": 0.4}'''),\n        \n        5: (\"Conciencia-Atencion\", '''\nclass DimensionConcienciaAtencion:\n    def __init__(self):\n        self.nombre = \"Conciencia-Atencion\"\n        self.magnitud = 0.0\n    \n    def procesar(self, datos):\n        return {\"dimension\": self.nombre, \"magnitud\": 0.2}'''),\n        \n        6: (\"Memoria-Persistencia\", '''\nclass DimensionMemoriaPersistencia:\n    def __init__(self):\n        self.nombre = \"Memoria-Persistencia\"\n        self.magnitud = 0.0\n    \n    def procesar(self, datos"
    },
    "vector_12d.py": {
      "tipo": "archivo",
      "extension": ".py",
      "tamano_bytes": 10474,
      "tamano_humano": "10.23 KB",
      "ruta": "vector_12d.py",
      "contenido_preview": "\"\"\"\nSISTEMA VECTORIAL 12D - VERSI√ìN CORREGIDA\nSistema unificado de 12 dimensiones vectoriales\n\"\"\"\nimport json\nimport time\nimport importlib\nimport sys\nimport os\nfrom typing import List, Dict, Any\n\n# Asegurar que podemos importar desde el directorio actual\nsys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nclass Vector12D:\n    \"\"\"Representa un vector en 12 dimensiones\"\"\"\n    def __init__(self, dimensiones: List[float]):\n        self.dimensiones = dimensiones\n        self.timestamp = time.time()\n        \n    def magnitud(self) -> float:\n        \"\"\"Calcula la magnitud del vector\"\"\"\n        import math\n        suma_cuadrados = sum(d * d for d in self.dimensiones)\n        return math.sqrt(suma_cuadrados) if suma_cuadrados > 0 else 0.0\n    \n    def normalizar(self) -> 'Vector12D':\n        \"\"\"Devuelve una versi√≥n normalizada del vector\"\"\"\n        mag = self.magnitud()\n        if mag > 0:\n            return Vector12D([d / mag for d in self.dimensiones])\n        return Vector12D([0.0] * 12)\n    \n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convierte el vector a diccionario\"\"\"\n        return {\n            'dimensiones': self.dimensiones,\n            'magnitud': self.magnitud(),\n            'timestamp': self.timestamp,\n            'dimensiones_count': len(self.dimensiones)\n        }\n    \n    def __str__(self) -> str:\n        \"\"\"Representaci√≥n en texto del vector\"\"\"\n        dim_str = \", \".join([f\"{d:.4f}\" for d in self.dimensiones])\n        return f\"Vector12D(mag={self.magnitud():.4f}, dims=[{dim_str}])\"\n\nclass SistemaVectorial12D:\n    \"\"\"Sistema principal que maneja las 12 dimensiones\"\"\"\n    \n    def __init__(self):\n        print(\"[Vector12D] Inicializando sistema vectorial...\")\n        self.dimensiones = []\n        self._cargar_dimensiones()\n        print(f\"[Vector12D] Sistema inicializado con {len(self.dimensiones)} dimensiones\")\n    \n    def _cargar_dimensiones(self):\n        \"\"\"Carga din√°micamente las 12 dimensiones\"\"\"\n        dimensiones_cargadas = 0\n        \n        for i in range(1, 13):\n            try:\n                # Construir el nombre del m√≥dulo\n                modulo_nombre = f\"dimensiones.dimension_{i}\"\n                \n                # Verificar si el archivo existe\n                archivo_dimension = f\"dimensiones/dimension_{i}.py\"\n                if not os.path.exists(archivo_dimension):\n                    print(f\"  [Vector12D] Advertencia: No existe {archivo_dimension}\")\n                    continue\n                \n                # Importar el m√≥dulo\n                modulo = importlib.import_module(modulo_nombre)\n                \n                # Buscar la clase principal en el m√≥dulo\n                clase_dimension = None\n                for nombre_clase in dir(modulo):\n                    # Filtrar nombres que contengan 'Dimension' o 'Dim'\n                    if 'Dimension' in nombre_clase or 'Dim' in nombre_clase:\n                        obj = getattr(modulo, nombre_clase)\n                        if isinstance(obj, type):  # Es una clase\n                            clase_dimension = obj\n                            break\n                \n                if clase_dimension:\n                    # Crear instancia de la dimensi√≥n\n                    instancia = clase_dimension()\n                    self.dimensiones.append(instancia)\n                    dimensiones_cargadas += 1\n                    print(f\"  [Vector12D] ‚úì Dimensi√≥n {i} cargada: {clase_dimension.__name__}\")\n                else:\n                    print(f\"  [Vector12D] ‚úó No se encontr√≥ clase en dimensi√≥n {i}\")\n                    \n            except ImportError as e:\n                print(f\"  [Vector12D] ‚úó Error importando dimensi√≥n {i}: {str(e)[:100]}\")\n            except Exception as e:\n                print(f\"  [Vector12D] ‚úó Error cargando dimensi√≥n {i}: {str(e)[:100]}\")\n        \n        # Si no se cargaron dimensiones, crear dimensiones por defecto\n        if dimensiones_cargadas == 0:\n            print(\"  [Vector12D] ‚ö†Ô∏è Creando dimensiones por defecto...\")\n            self._crear_dimensiones_por_defecto()\n    \n    def _crear_dimensiones_por_defecto(self):\n        \"\"\"Crea dimensiones b√°sicas por defecto si no se pueden cargar las reales\"\"\"\n        class DimensionBase:\n            def __init__(self, nombre, indice):\n                self.nombre = nombre\n                self.indice = indice\n                self.contador = 0\n            \n            def procesar(self, evento):\n                self.contador += 1\n                # Valor simple basado en el √≠ndice y longitud del evento\n                valor = 0.1 * self.indice + 0.01 * len(str(evento))\n                return {'magnitud': valor, 'procesado': True, 'dimension': self.indice}\n        \n        nombres = [\n            \"Tiempo-Entrop√≠a\", \"Espacio-Volumen\", \"Energ√≠a-Potencial\",\n            \"Informaci√≥n-Entrop√≠a\", \"Conciencia-Atenci√≥n\", \"Memoria-Persistencia\",\n            \"Aprendizaje-Adaptaci√≥n\", \"Creatividad-Generaci√≥n\", \"Ejecuci√≥n-Acci√≥"
    },
    "verificar.py": {
      "tipo": "archivo",
      "extension": ".py",
      "tamano_bytes": 1307,
      "tamano_humano": "1.28 KB",
      "ruta": "verificar.py",
      "contenido_preview": "import zipfile \nimport os \n \nprint(\"?? VERIFICACIN DE VECTA 12D\") \nprint(\"=\"*50) \n \nzip_file = \"VECTA_12D_Automatico.zip\" \n \nprint(\"1. Verificando ZIP...\") \nif os.path.exists(zip_file): \n    size = os.path.getsize(zip_file) \n    print(f\"   V ZIP existe: {size} bytes ({size/1024:.1f} KB)\") \nelse: \n    print(f\"   ? ZIP no encontrado\") \n \nprint(\"2. Contenido del ZIP:\") \ntry: \n    with zipfile.ZipFile(zip_file, \"r\") as z: \n        files = z.namelist() \n        print(f\"   V {len(files)} archivos encontrados:\") \n        for file in files: \n            info = z.getinfo(file) \n            print(f\"     \u0007 {file} ({info.file_size} bytes)\") \nexcept Exception as e: \n    print(f\"   ? Error: {e}\") \n \nprint(\"3. Verificando archivos requeridos:\") \nrequired = [\"INSTAR.bat\", \"vecta_self_install.py\", \"vecta_12d_launcher.py\", \"paquete_vecta.pkg\"] \ntry: \n    with zipfile.ZipFile(zip_file, \"r\") as z: \n        zip_files = z.namelist() \n        for req in required: \n            if req in zip_files: \n                print(f\"   V {req} - PRESENTE\") \n            else: \n                print(f\"   ? {req} - FALTANTE\") \nexcept: \n    print(\"   ? No se pudo verificar\") \n \nprint(\"=\"*50) \nprint(\"? VERIFICACIN COMPLETADA\") \nprint(\"\\nPara instalar:\") \nprint(\"1. Extrae el ZIP\") \n"
    },
    "verificar.pypython": {
      "tipo": "archivo",
      "extension": ".pypython",
      "tamano_bytes": 67,
      "tamano_humano": "0.07 KB",
      "ruta": "verificar.pypython",
      "contenido_preview": null
    }
  },
  "estadisticas": {
    "total_archivos": 61,
    "total_carpetas": 5,
    "tamano_total_bytes": 394836,
    "extensiones": {
      ".pyc": 17,
      ".py": 35,
      ".backup": 1,
      "sin_extension": 1,
      ".bat": 1,
      ".pkg": 1,
      ".json": 1,
      ".zip": 1,
      ".backup_20251225_185345": 1,
      ".pydir": 1,
      ".pypython": 1
    }
  },
  "contenidos_importantes": {}
}